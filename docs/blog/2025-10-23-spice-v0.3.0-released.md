---
slug: spice-v0.3.0-released
title: Spice v0.3.0 Released - Unified Flow Orchestration
authors: [spice-team]
tags: [release, breaking-change, flow, orchestration]
---

# Spice v0.3.0: Unified Flow Orchestration

We're excited to announce **Spice v0.3.0**, a major release that brings powerful, unified flow orchestration to the framework!

This release removes the confusing `CoreFlow` abstraction and unifies everything under `MultiAgentFlow`, giving you **conditional execution**, **4 execution strategies**, and **runtime strategy selection** out of the box.

<!--truncate-->

## üéØ What's New

### Unified Flow System

**The Problem:** In v0.2.x, `buildFlow` returned a `CoreFlow` that couldn't actually execute. Users were confused why `flow.execute()` didn't exist.

**The Solution:** `buildFlow` now returns `MultiAgentFlow` with full execution support:

```kotlin
val flow = buildFlow {
    id = "data-pipeline"
    name = "Data Processing Pipeline"
    strategy = FlowStrategy.SEQUENTIAL

    step("validate", "validator")
    step("process", "processor")
    step("store", "storage")
}

// Execute immediately!
runBlocking {
    val result = flow.process(
        Comm(content = "Process this data", from = "user")
    )
}
```

---

## üöÄ Major Features

### 1. Conditional Step Execution

Control which agents execute based on runtime conditions:

```kotlin
val flow = buildFlow {
    name = "Smart Pipeline"
    strategy = FlowStrategy.SEQUENTIAL

    step("validate", "validator")

    // Only process if validation passed
    step("process", "processor") { comm ->
        comm.data["valid"] == "true"
    }

    // Only store if processing succeeded
    step("store", "storage") { comm ->
        comm.data["processed"] == "true"
    }
}
```

Conditions are evaluated at runtime, allowing dynamic flow control based on message content and previous step results.

---

### 2. Four Execution Strategies

Choose how your agents execute:

#### Sequential (Default)
Agents execute one by one: A ‚Üí B ‚Üí C
```kotlin
val flow = buildFlow {
    strategy = FlowStrategy.SEQUENTIAL
    step("step1", "agent1")
    step("step2", "agent2")
    step("step3", "agent3")
}
```
Perfect for workflows where order matters.

#### Parallel
All agents execute simultaneously:
```kotlin
val flow = buildFlow {
    strategy = FlowStrategy.PARALLEL
    step("task1", "agent1")
    step("task2", "agent2")
    step("task3", "agent3")
}
```
Great for independent tasks that can run concurrently.

#### Competition
First successful response wins:
```kotlin
val flow = buildFlow {
    strategy = FlowStrategy.COMPETITION
    step("gpt", "gpt-4")
    step("claude", "claude-3-5")
    step("gemini", "gemini-pro")
}
```
Ideal for getting the fastest response from multiple LLM providers.

#### Pipeline
Output flows through agents like a data pipeline:
```kotlin
val flow = buildFlow {
    strategy = FlowStrategy.PIPELINE
    step("extract", "extractor")
    step("transform", "transformer")
    step("load", "loader")
}
```
Classic ETL pattern: each agent transforms and passes data forward.

---

### 3. Dynamic Strategy Selection

Choose execution strategy at runtime based on message content:

```kotlin
val flow = buildFlow {
    id = "adaptive-flow"
    step("agent1", "agent1")
    step("agent2", "agent2")
    step("agent3", "agent3")
}

flow.setStrategyResolver { comm, agents ->
    when {
        comm.data["urgent"] == "true" -> FlowStrategy.COMPETITION
        comm.data["mode"] == "parallel" -> FlowStrategy.PARALLEL
        agents.size > 5 -> FlowStrategy.PIPELINE
        else -> FlowStrategy.SEQUENTIAL
    }
}
```

The framework selects the optimal strategy for each message!

---

### 4. Convenience Functions & Operators

Quick flow creation with helper functions:

```kotlin
import io.github.noailabs.spice.*

// Convenience functions
val seq = sequentialFlow(agent1, agent2, agent3)
val par = parallelFlow(agent1, agent2, agent3)
val comp = competitionFlow(agent1, agent2, agent3)
val pipe = pipelineFlow(agent1, agent2, agent3)

// Operators
val flow1 = agent1 + agent2           // Sequential
val flow2 = agent1 parallelWith agent2 // Parallel
val flow3 = agent1 competesWith agent2 // Competition
```

---

### 5. Enhanced Integration Support

Neo4j, PSI, and Mnemo integrations now capture flow structure:

```kotlin
// Neo4j graph includes step relationships
val graph = flow.toNeo4jGraph()
// Now shows: Flow ‚Üí Step 1 ‚Üí Agent 1
//           Flow ‚Üí Step 2 ‚Üí Agent 2 (with condition)

// PSI includes step metadata
val psi = flow.toPsi()
// Includes: stepIndex, agentId, hasCondition

// Mnemo captures execution patterns
MnemoIntegration.saveFlowExecution(flow, input, output, mnemo)
```

---

## üíî Breaking Changes

### CoreFlow Removed

`CoreFlow`, `CoreFlowBuilder`, and `FlowStep` have been removed. All flow functionality is now in `MultiAgentFlow`.

**Before (v0.2.x):**
```kotlin
val flow = buildFlow {
    step("step1", "agent1")
}
// Type: CoreFlow
// No execute() method!
```

**After (v0.3.0):**
```kotlin
val flow = buildFlow {
    strategy = FlowStrategy.SEQUENTIAL
    step("step1", "agent1")
}
// Type: MultiAgentFlow
runBlocking {
    val result = flow.process(comm)  // ‚úÖ Works!
}
```

### Migration is Easy

Most flows need minimal changes:
1. Add `strategy` parameter (optional, defaults to SEQUENTIAL)
2. Use `flow.process(comm)` to execute
3. Update type annotations from `CoreFlow` to `MultiAgentFlow`

See the [Migration Guide](https://github.com/noailabs/spice/blob/main/docs/MIGRATION_GUIDE_v0.3.md) for complete instructions.

---

## üìä What This Means for You

### Before v0.3.0
- ‚ùå Confusing: `buildFlow` returned `CoreFlow` that couldn't execute
- ‚ùå Limited: Only one execution pattern (sequential through MultiAgentFlow)
- ‚ùå Static: No runtime strategy selection
- ‚ùå Manual: Had to use MultiAgentFlow directly for real workflows

### After v0.3.0
- ‚úÖ Clear: `buildFlow` returns executable `MultiAgentFlow`
- ‚úÖ Flexible: 4 execution strategies + custom resolvers
- ‚úÖ Dynamic: Conditions and runtime strategy selection
- ‚úÖ Powerful: Convenience functions, operators, and enhanced integrations

---

## üìö Documentation

We've completely rewritten the flow documentation:

- **[buildFlow Guide](/docs/dsl-guide/build-flow)** - Complete guide with examples
- **[Flow Orchestration](/docs/orchestration/flows)** - Multi-agent patterns
- **[DSL API Reference](/docs/api/dsl#flow-dsl)** - Full API documentation
- **[Migration Guide](https://github.com/noailabs/spice/blob/main/docs/MIGRATION_GUIDE_v0.3.md)** - Step-by-step migration

All documentation includes:
- Runnable code examples
- Strategy selection guides
- Best practices
- Real-world use cases

---

## üéì Real-World Example

Here's a complete validation pipeline that showcases the new features:

```kotlin
import io.github.noailabs.spice.*
import io.github.noailabs.spice.dsl.*
import kotlinx.coroutines.runBlocking

fun main() = runBlocking {
    // Create validation agents
    val validator = buildAgent {
        id = "validator"
        name = "Input Validator"
        handle { comm ->
            val isValid = comm.content.length >= 10
            SpiceResult.success(
                comm.reply(
                    content = if (isValid) "Valid" else "Invalid",
                    from = id,
                    data = mapOf("valid" to isValid.toString())
                )
            )
        }
    }

    val processor = buildAgent {
        id = "processor"
        name = "Data Processor"
        handle { comm ->
            SpiceResult.success(
                comm.reply(
                    content = "Processed: ${comm.content.uppercase()}",
                    from = id,
                    data = mapOf("processed" to "true")
                )
            )
        }
    }

    // Register agents
    AgentRegistry.register(validator)
    AgentRegistry.register(processor)

    // Create conditional flow
    val flow = buildFlow {
        id = "validation-pipeline"
        name = "Validation Pipeline"
        strategy = FlowStrategy.SEQUENTIAL

        step("validate", "validator")

        // Only process if valid
        step("process", "processor") { comm ->
            comm.data["valid"] == "true"
        }
    }

    // Test with valid input
    println("=== Valid Input ===")
    val result1 = flow.process(
        Comm(content = "This is a valid message", from = "user")
    )
    println(result1.content)
    println("Time: ${result1.data["execution_time_ms"]}ms")

    // Test with invalid input
    println("\n=== Invalid Input ===")
    val result2 = flow.process(
        Comm(content = "Short", from = "user")
    )
    println(result2.content)
    // Processor step skipped due to condition!
}
```

Output:
```
=== Valid Input ===
Processed: THIS IS A VALID MESSAGE
Time: 145ms

=== Invalid Input ===
Invalid
Time: 52ms
```

---

## üôè Acknowledgments

Special thanks to everyone who provided feedback on the confusing `CoreFlow` API. Your input helped shape this release into something much more intuitive and powerful.

---

## üîÆ What's Next

Looking ahead to v0.4.0:
- Enhanced error handling in flows
- Flow composition and nesting
- Built-in retry strategies
- Flow execution history and replay
- Visual flow builder (experimental)

Stay tuned!

---

## üì¶ Installation

### Gradle (Kotlin)
```kotlin
dependencies {
    implementation("io.github.noailabs:spice-core:0.3.0")
}
```

### Gradle (Groovy)
```groovy
dependencies {
    implementation 'io.github.noailabs:spice-core:0.3.0'
}
```

### Maven
```xml
<dependency>
    <groupId>io.github.noailabs</groupId>
    <artifactId>spice-core</artifactId>
    <version>0.3.0</version>
</dependency>
```

---

## üîó Resources

- [Documentation](https://spice.noailabs.io)
- [GitHub Repository](https://github.com/noailabs/spice)
- [Migration Guide](https://github.com/noailabs/spice/blob/main/docs/MIGRATION_GUIDE_v0.3.md)
- [Examples](/docs/examples)

---

**Happy building with Spice v0.3.0!** üå∂Ô∏èüöÄ

If you encounter any issues, please [open an issue on GitHub](https://github.com/noailabs/spice/issues).
