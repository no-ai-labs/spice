---
slug: spice-v0.4.0-released
title: Spice v0.4.0 - Context Revolution üéØ
authors: [spice-team]
tags: [release, context, multi-tenancy, production]
---

# Spice v0.4.0: Context Revolution üéØ

We're thrilled to announce **Spice v0.4.0** - the biggest update yet, introducing **automatic context propagation** throughout your entire agent system!

<!--truncate-->

## What's New?

v0.4.0 introduces a revolutionary approach to context management in multi-agent systems. Say goodbye to manual parameter passing and hello to automatic context propagation via Kotlin's CoroutineContext system.

### üöÄ Automatic Context Propagation

**Before (v0.3.0):**
```kotlin
class MyAgent : BaseAgent(...) {
    override suspend fun processComm(
        comm: Comm,
        runtime: AgentRuntime
    ): SpiceResult<Comm> {
        val context = runtime.context
        val tenantId = context.getAs<String>("tenantId")

        // Manually create ToolContext
        val toolContext = ToolContext(
            agentId = id,
            tenantId = tenantId,
            userId = context.getAs("userId")
        )

        // Manually pass context to every tool
        myTool.execute(params, toolContext)
    }
}
```

**After (v0.4.0):**
```kotlin
// Set context once at the entry point
withAgentContext(
    "userId" to "user-123",
    "tenantId" to "CHIC"
) {
    // Context automatically propagates everywhere!
    agent.processComm(comm)  // ‚úÖ Has context

    launch {
        service.doWork()      // ‚úÖ Has context
    }

    async {
        repository.query()    // ‚úÖ Has context
    }
}
```

Zero boilerplate. Zero manual passing. Just works. üéâ

### üéØ Context-Aware Tool DSL

Create tools that automatically receive AgentContext:

```kotlin
// New in v0.4.0
val policyLookup = contextAwareTool("policy_lookup") {
    description = "Look up policy by type"
    param("policyType", "string", "Policy type")

    execute { params, context ->
        // ‚úÖ Context automatically injected!
        val tenantId = context.tenantId ?: "CHIC"
        val userId = context.userId ?: "unknown"
        val policyType = params["policyType"] as String

        policyService.lookup(tenantId, policyType)
    }
}
```

No more `getCurrentToolContext()` or manual parameter passing. The context is just... there.

### üèóÔ∏è Service Layer Context Support

Repositories and services can now access context automatically:

```kotlin
class PolicyService : BaseContextAwareService() {

    // tenantId automatically from context!
    suspend fun lookup(policyType: String): Policy = withTenant { tenantId ->
        repository.find(tenantId, policyType)
    }

    // Both IDs automatically from context
    suspend fun create(policy: Policy): Policy = withTenantAndUser { tenantId, userId ->
        repository.save(policy.copy(
            tenantId = tenantId,
            createdBy = userId
        ))
    }
}
```

Perfect for multi-tenant architectures. No tenant ID leakage. No manual parameter threading.

### üîå Context Extension System

Runtime context enrichment with plugins:

```kotlin
// Register tenant extension
val tenantExtension = TenantContextExtension { tenantId ->
    mapOf(
        "features" to listOf("feature1", "feature2"),
        "limits" to mapOf("max_requests" to 1000),
        "config" to loadTenantConfig(tenantId)
    )
}

ContextExtensionRegistry.register(tenantExtension)

// Extensions automatically enrich context
val enriched = ContextExtensionRegistry.enrichContext(baseContext)
```

Load tenant configs, user permissions, feature flags - all automatically when context is created.

### üí¨ Comm Context Integration

Comm now carries AgentContext for message-level context:

```kotlin
val comm = Comm(
    content = "Hello",
    from = "user"
).withContext(
    AgentContext.of("tenantId" to "CHIC", "userId" to "user-123")
)

// Access context from comm
val tenantId = comm.getContextValue("tenantId")
```

Perfect for event-driven architectures and message queues.

## Why This Matters

### Multi-Tenancy

**Perfect tenant isolation** with zero effort:

```kotlin
withAgentContext("tenantId" to "CHIC") {
    // Every database query, every service call, every tool execution
    // automatically scoped to tenant "CHIC"
    agent.processComm(comm)
}
```

No risk of tenant data leakage. No manual tenant ID passing. Just works.

### Distributed Tracing

**End-to-end tracing** across all agents, tools, and services:

```kotlin
withAgentContext(
    "traceId" to UUID.randomUUID().toString(),
    "spanId" to generateSpanId()
) {
    // Trace context automatically propagated to:
    // - All agents in swarm
    // - All tools
    // - All service calls
    // - All database queries
    swarmAgent.processComm(comm)
}
```

Perfect for OpenTelemetry integration.

### Production-Ready

This release was driven by **real production needs** from KAI-Core, a multi-tenant AI system processing thousands of requests per day.

Key production features:
- ‚úÖ Thread-safe (immutable context)
- ‚úÖ Zero-cost abstraction (Kotlin CoroutineContext)
- ‚úÖ Automatic propagation (no manual passing)
- ‚úÖ Type-safe accessors (context.tenantId)
- ‚úÖ Extension system (runtime enrichment)
- ‚úÖ Backwards compatible (ToolContext still works)

## Breaking Changes

### AgentContext is Now Immutable

```kotlin
// ‚ùå No longer works
context["key"] = "value"

// ‚úÖ Use immutable updates
val updated = context.with("key", "value")

// ‚úÖ Or bulk updates
val enriched = context.withAll(
    "key1" to "value1",
    "key2" to "value2"
)
```

This ensures **thread-safety** and enables **structural sharing** for better performance.

### AgentContext Extends CoroutineContext.Element

AgentContext is now a `CoroutineContext.Element`:

```kotlin
data class AgentContext(
    private val data: Map<String, Any> = emptyMap()
) : AbstractCoroutineContextElement(AgentContext) {
    companion object Key : CoroutineContext.Key<AgentContext>
}
```

This enables automatic propagation through coroutine boundaries.

## Migration

Migration is straightforward for most codebases:

### Step 1: Replace Mutable Operations

```kotlin
// Before
val context = AgentContext.empty()
context["userId"] = "user-123"

// After
val context = AgentContext.of("userId" to "user-123")
```

### Step 2: Adopt withAgentContext DSL

```kotlin
// Before
val runtime = DefaultAgentRuntime(
    context = AgentContext.of("tenantId" to "CHIC")
)
agent.processComm(comm, runtime)

// After
withAgentContext("tenantId" to "CHIC") {
    agent.processComm(comm)
}
```

### Step 3: Use Context-Aware Tools

```kotlin
// Before
tool("my_tool") {
    execute { params ->
        val toolContext = getCurrentToolContext()
        val tenantId = toolContext.tenantId
    }
}

// After
contextAwareTool("my_tool") {
    execute { params, context ->
        val tenantId = context.tenantId  // ‚úÖ Automatic!
    }
}
```

See the [Migration Guide](../MIGRATION_GUIDE_v0.4.0.md) for complete details.

## Performance

v0.4.0 is **faster** than v0.3.0:

- ‚úÖ Immutable context eliminates lock contention
- ‚úÖ CoroutineContext integration is zero-cost
- ‚úÖ No ToolContext conversion overhead
- ‚úÖ Structural sharing reduces allocations

## Real-World Example

Here's a complete multi-tenant order processing system:

```kotlin
// Service layer
class OrderService : BaseContextAwareService() {
    suspend fun createOrder(order: Order): Order = withTenantAndUser { tenantId, userId ->
        // tenantId and userId automatically from context!
        val enriched = order.copy(
            tenantId = tenantId,
            createdBy = userId,
            createdAt = Instant.now()
        )
        repository.save(enriched)
    }

    suspend fun listOrders(): List<Order> = withTenant { tenantId ->
        repository.findAllByTenant(tenantId)
    }
}

// Agent with context-aware tool
buildAgent {
    id = "order-agent"

    contextAwareTool("create_order") {
        description = "Create new order"
        param("items", "array", "Order items")

        execute { params, context ->
            // ‚úÖ Context automatic!
            val tenantId = context.tenantId ?: throw IllegalStateException("No tenant")

            val order = Order(
                items = params["items"] as List<*>,
                tenantId = tenantId
            )

            orderService.createOrder(order)
        }
    }
}

// Usage - set context once
withAgentContext(
    "tenantId" to "customer-123",
    "userId" to "user-456",
    "traceId" to UUID.randomUUID().toString()
) {
    // All operations tenant-scoped automatically
    agent.processComm(
        Comm(content = "Create order: laptop, mouse", from = "user-456")
    )

    // Trace ID propagates to all logs, metrics, and spans
}
```

## What's Next?

This release sets the foundation for:

- **v0.5.0**: Advanced observability (metrics, tracing integration)
- **v0.6.0**: Persistence layer (state management, event sourcing)
- **v0.7.0**: Production tools (rate limiting, circuit breakers, retries)

## Try It Now

```kotlin
// build.gradle.kts
dependencies {
    implementation("io.github.noailabs:spice-core:0.4.0")
}
```

## Resources

- [Context Propagation Guide](../docs/advanced/context-propagation.md)
- [Migration Guide v0.4.0](../MIGRATION_GUIDE_v0.4.0.md)
- [API Reference](../docs/api/dsl.md)
- [GitHub Repository](https://github.com/noailabs/spice)

## Acknowledgments

Special thanks to the KAI-Core team for driving the requirements for this release with their production multi-tenant AI system. This release is proof that **production drives innovation**.

---

**Ready to revolutionize your context management?** Upgrade to v0.4.0 today! üöÄ

Questions? Feedback? [Open an issue](https://github.com/noailabs/spice/issues) or join the discussion!
