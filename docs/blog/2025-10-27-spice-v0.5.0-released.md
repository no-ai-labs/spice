---
slug: spice-v0.5.0-released
title: Spice v0.5.0 - Graph System & Human-in-the-Loop ğŸ•¸ï¸
authors: [spice-team]
tags: [release, graph, orchestration, hitl, middleware, checkpoint, microsoft-af, breaking-change]
---

# Spice v0.5.0: Graph System & Human-in-the-Loop ğŸ•¸ï¸

We're thrilled to announce **Spice v0.5.0** - our biggest architectural release yet! This major release introduces graph-based orchestration inspired by Microsoft's Agent Framework, replacing the Swarm/Flow patterns with a unified, powerful Graph system.

<!--truncate-->

## TL;DR - What's New?

This is a **major release** with **breaking changes** and amazing new features:

- ğŸ•¸ï¸ **Graph System** - DAG-based orchestration (Swarm/Flow â†’ Graph)
- ğŸ”„ **Middleware** - Intercept execution for logging, metrics, observability
- ğŸ’¾ **Checkpointing** - Save and resume graph execution
- ğŸ‘¤ **HITL Support** - Pause graphs for human approval
- ğŸ¤ **Agent Handoff** - Seamless agent â†’ human transfers
- ğŸ“¦ **GraphRegistry** - Centralized graph management with full lifecycle support
- âš ï¸ **FlowRegistry Deprecated** - Clear migration path with IDE assistance
- ğŸ”§ **CachedTool Improved** - Deterministic LRU eviction for better performance
- ğŸ“š **4900+ lines of docs** - Complete guides and examples
- âœ… **30 new tests** - Comprehensive test coverage including context integration

**Migration Required**: If you use `swarm {}` or `flow {}`, you must migrate to `graph {}`. See [Migration Guide](#migration-guide) below.

---

## Why This Release Matters

### The Problem with Swarm/Flow

In Spice 0.4.x, we had two orchestration patterns:
- **Swarm** - Multi-agent coordination with strategies
- **Flow** - Sequential agent execution

While powerful, these patterns had limitations:
- âŒ **Limited flexibility** - Linear or predefined strategies
- âŒ **No state management** - Couldn't pause and resume
- âŒ **No human oversight** - All-AI or manual orchestration
- âŒ **Poor composability** - Hard to build complex workflows

### The Solution: Graph-Based Orchestration

Spice 0.5.0 introduces a **unified Graph system** inspired by Microsoft's Agent Framework:

- âœ… **DAG execution** - Directed Acyclic Graphs for any workflow
- âœ… **Conditional routing** - Route based on runtime data
- âœ… **State management** - Checkpoint and resume execution
- âœ… **Human-in-the-Loop** - Pause for human approval
- âœ… **Better composability** - Combine simple graphs into complex systems
- âœ… **Industry-aligned** - Matches Microsoft AF design philosophy

---

## Feature Deep Dive

### 1. Graph System - The New Orchestration Core ğŸ•¸ï¸

At the heart of 0.5.0 is the **Graph system** - a flexible, DAG-based orchestration engine.

#### Basic Graph

```kotlin
val customerSupportGraph = graph("customer-support") {
    // Define nodes
    agent("classifier", classifierAgent)
    agent("technical", technicalAgent)
    agent("billing", billingAgent)

    // Define edges (conditional routing)
    edge("classifier", "technical") { result ->
        val comm = result.data as? Comm
        comm?.data?.get("category") == "technical"
    }

    edge("classifier", "billing") { result ->
        val comm = result.data as? Comm
        comm?.data?.get("category") == "billing"
    }
}

// Execute the graph
val runner = DefaultGraphRunner()
val result = runner.run(
    graph = customerSupportGraph,
    input = mapOf("comm" to initialComm)
).getOrThrow()

println("Final result: ${result.result}")
println("Executed ${result.nodeReports.size} nodes")
```

#### What Makes It Powerful?

**Multiple Node Types**:
- `agent()` - Execute an agent
- `tool()` - Execute a tool
- `output()` - Produce output
- `decision()` - Branch based on logic
- `humanNode()` - Pause for human input

**Conditional Edges**:
```kotlin
graph("smart-routing") {
    agent("analyzer", analyzerAgent)

    // Route to different agents based on priority
    edge("analyzer", "urgent-handler") { result ->
        result.data?.get("priority") == "urgent"
    }

    edge("analyzer", "normal-handler") { result ->
        result.data?.get("priority") == "normal"
    }
}
```

**Reusable Agents**:
```kotlin
graph("multi-step") {
    // Same agent used in different stages
    agent("validate-input", validatorAgent)
    agent("process", processorAgent)
    agent("validate-output", validatorAgent)  // Reused!

    edge("validate-input", "process")
    edge("process", "validate-output")
}
```

---

### 2. Middleware - Cross-Cutting Concerns Made Easy ğŸ”„

Middleware lets you intercept graph execution at every stage - perfect for logging, metrics, error handling, and observability.

#### Simple Logging Middleware

```kotlin
class LoggingMiddleware : Middleware {
    override suspend fun onGraphStart(context: GraphContext) {
        println("ğŸš€ Starting graph: ${context.graphId}")
    }

    override suspend fun onNodeExecute(
        node: Node,
        context: NodeContext
    ): SpiceResult<NodeResult> {
        println("âš™ï¸ Executing node: ${node.id}")
        val startTime = System.currentTimeMillis()

        val result = middleware.next(node, context)

        val duration = System.currentTimeMillis() - startTime
        println("âœ… Node ${node.id} completed in ${duration}ms")

        return result
    }

    override suspend fun onNodeError(
        node: Node,
        error: SpiceError,
        context: NodeContext
    ): ErrorAction {
        println("âŒ Node ${node.id} failed: ${error.message}")
        return ErrorAction.PROPAGATE  // Let error bubble up
    }

    override suspend fun onGraphFinish(
        context: GraphContext,
        result: SpiceResult<Any?>
    ) {
        println("ğŸ Graph ${context.graphId} finished")
    }
}

// Use the middleware
val monitoredGraph = graph("monitored-workflow") {
    agent("step1", agent1)
    agent("step2", agent2)

    middleware(LoggingMiddleware())
}
```

#### Metrics Middleware

```kotlin
class MetricsMiddleware : Middleware {
    private val nodeExecutionTimes = CopyOnWriteArrayList<Pair<String, Long>>()

    override suspend fun onNodeExecute(
        node: Node,
        context: NodeContext
    ): SpiceResult<NodeResult> {
        val startTime = System.currentTimeMillis()
        val result = middleware.next(node, context)
        val duration = System.currentTimeMillis() - startTime

        nodeExecutionTimes.add(node.id to duration)

        // Send to monitoring system
        metricsCollector.recordNodeExecution(node.id, duration)

        return result
    }

    fun getMetrics(): Map<String, Long> {
        return nodeExecutionTimes.toMap()
    }
}
```

#### Error Handling with Retry

```kotlin
class RetryMiddleware(val maxRetries: Int = 3) : Middleware {
    override suspend fun onNodeError(
        node: Node,
        error: SpiceError,
        context: NodeContext
    ): ErrorAction {
        val attempt = context.state["${node.id}_retry_count"] as? Int ?: 0

        return if (attempt < maxRetries) {
            context.state["${node.id}_retry_count"] = attempt + 1
            println("ğŸ”„ Retrying node ${node.id} (attempt ${attempt + 1}/$maxRetries)")
            ErrorAction.RETRY
        } else {
            println("ğŸ’€ Max retries reached for node ${node.id}")
            ErrorAction.PROPAGATE
        }
    }
}

// Graph with retry logic
val resilientGraph = graph("resilient-workflow") {
    agent("unstable-service", unstableAgent)
    middleware(RetryMiddleware(maxRetries = 3))
}
```

**Error Actions**:
- `PROPAGATE` - Let error bubble up (fail graph)
- `RETRY` - Re-execute the failed node
- `SKIP` - Skip the failed node, continue execution
- `CONTINUE(fallbackResult)` - Provide fallback value and continue

**Why Middleware Matters**:
- ğŸ“Š **Observability** - Track execution flow and performance
- ğŸ› **Debugging** - Log node execution for troubleshooting
- ğŸ”„ **Retry Logic** - Automatically retry failed operations
- ğŸ“ˆ **Metrics** - Collect execution statistics
- ğŸ¯ **Custom Behavior** - Inject any cross-cutting concern

---

### 3. Checkpointing - Fault Tolerance & Long-Running Workflows ğŸ’¾

Checkpointing allows you to save graph execution state and resume later - essential for long-running workflows and HITL scenarios.

#### Basic Checkpointing

```kotlin
val checkpointStore = InMemoryCheckpointStore()

// Run with automatic checkpointing
val result = runner.runWithCheckpoint(
    graph = myGraph,
    input = mapOf("data" to myData),
    store = checkpointStore,
    config = CheckpointConfig(
        saveEveryNNodes = 5,  // Save every 5 nodes
        autoSave = true
    )
).getOrThrow()

// If execution fails, resume from checkpoint
if (result.status == RunStatus.FAILED) {
    val resumed = runner.resume(
        graph = myGraph,
        checkpointId = result.checkpointId!!,
        store = checkpointStore
    ).getOrThrow()
}
```

#### Production Checkpoint Storage

```kotlin
// File-based storage (production)
class FileCheckpointStore(val directory: File) : CheckpointStore {
    override suspend fun save(checkpoint: Checkpoint): SpiceResult<Unit> {
        val file = File(directory, "${checkpoint.id}.json")
        file.writeText(Json.encodeToString(checkpoint))
        return SpiceResult.success(Unit)
    }

    override suspend fun load(checkpointId: String): SpiceResult<Checkpoint> {
        val file = File(directory, "$checkpointId.json")
        if (!file.exists()) {
            return SpiceResult.failure(
                ResourceNotFoundError("Checkpoint not found: $checkpointId")
            )
        }
        val checkpoint = Json.decodeFromString<Checkpoint>(file.readText())
        return SpiceResult.success(checkpoint)
    }
}

// Database storage (enterprise)
class DatabaseCheckpointStore(val db: Database) : CheckpointStore {
    override suspend fun save(checkpoint: Checkpoint): SpiceResult<Unit> {
        db.insert("checkpoints")
            .values(
                "id" to checkpoint.id,
                "graph_id" to checkpoint.graphId,
                "state" to Json.encodeToString(checkpoint),
                "created_at" to Instant.now()
            )
            .execute()
        return SpiceResult.success(Unit)
    }

    override suspend fun load(checkpointId: String): SpiceResult<Checkpoint> {
        val row = db.select("checkpoints")
            .where("id" to checkpointId)
            .first()

        if (row == null) {
            return SpiceResult.failure(
                ResourceNotFoundError("Checkpoint not found")
            )
        }

        val checkpoint = Json.decodeFromString<Checkpoint>(
            row["state"] as String
        )
        return SpiceResult.success(checkpoint)
    }
}
```

**Use Cases**:
- ğŸ”„ **Fault Tolerance** - Survive crashes and restarts
- â±ï¸ **Long-Running Workflows** - Execute workflows over days/weeks
- ğŸ‘¤ **Human Approval** - Wait for human input (HITL)
- ğŸ“Š **Audit Trail** - Track execution history
- ğŸ” **Debugging** - Inspect state at any point

---

### 4. Human-in-the-Loop (HITL) - The Game Changer ğŸ‘¤

HITL is perhaps the most powerful feature in 0.5.0. It allows graphs to **pause synchronously** and wait for human approval, review, or input before continuing.

#### Approval Workflow

```kotlin
val approvalWorkflow = graph("content-approval") {
    // AI agent creates draft
    agent("draft", draftCreatorAgent)

    // Pause for human review
    humanNode(
        id = "review",
        prompt = "Please review the draft content and approve or reject",
        options = listOf(
            HumanOption(
                id = "approve",
                label = "Approve",
                description = "Approve draft and proceed to publication"
            ),
            HumanOption(
                id = "reject",
                label = "Reject",
                description = "Reject draft and request rewrite"
            ),
            HumanOption(
                id = "edit",
                label = "Request Edits",
                description = "Approve with minor edits needed"
            )
        ),
        timeout = Duration.ofMinutes(30),
        validator = { response ->
            // Ensure valid choice was made
            response.selectedOption in setOf("approve", "reject", "edit")
        }
    )

    // AI agent publishes
    agent("publish", publisherAgent)

    // Conditional routing based on human decision
    edge("review", "publish") { result ->
        val response = result.data as? HumanResponse
        response?.selectedOption == "approve"
    }

    edge("review", "draft") { result ->
        val response = result.data as? HumanResponse
        response?.selectedOption == "reject"
    }
}
```

#### Executing HITL Workflow

```kotlin
val checkpointStore = InMemoryCheckpointStore()

// Step 1: Start the graph (will pause at humanNode)
val pausedResult = runner.runWithCheckpoint(
    graph = approvalWorkflow,
    input = mapOf("content" to "Draft content here"),
    store = checkpointStore
).getOrThrow()

// Check if graph paused for human
if (pausedResult.status == RunStatus.PAUSED) {
    val interaction = pausedResult.result as HumanInteraction

    println("Graph paused at: ${interaction.nodeId}")
    println("Prompt: ${interaction.prompt}")
    println("Options: ${interaction.options.map { it.label }}")
    println("Expires at: ${interaction.expiresAt}")
}

// Step 2: Get pending interactions (optional)
val pending = runner.getPendingInteractions(
    checkpointId = pausedResult.checkpointId!!,
    store = checkpointStore
).getOrThrow()

println("You have ${pending.size} pending approval(s)")

// Step 3: Human provides response
val humanResponse = HumanResponse.choice(
    nodeId = "review",
    optionId = "approve"
)

// Step 4: Resume with human response
val finalResult = runner.resumeWithHumanResponse(
    graph = approvalWorkflow,
    checkpointId = pausedResult.checkpointId!!,
    response = humanResponse,
    store = checkpointStore
).getOrThrow()

println("Workflow completed: ${finalResult.result}")
```

#### Free Text Input

```kotlin
val feedbackGraph = graph("collect-feedback") {
    agent("analyze", analysisAgent)

    // Free text input (no options = free text)
    humanNode(
        id = "feedback",
        prompt = "Please provide detailed feedback (minimum 20 characters)",
        timeout = Duration.ofHours(24),
        validator = { response ->
            response.text?.length?.let { it >= 20 } ?: false
        }
    )

    output("result") { ctx ->
        val feedback = ctx.state["feedback"] as? HumanResponse
        "Analysis complete. Feedback: ${feedback?.text}"
    }
}

// Provide free text response
val textResponse = HumanResponse.text(
    nodeId = "feedback",
    text = "This analysis is excellent and covers all key points. " +
           "I suggest we proceed with implementation."
)
```

#### Multi-Stage Approval

```kotlin
val multiStageApproval = graph("multi-approval") {
    agent("draft", draftAgent)

    // First approval: Line manager
    humanNode(
        id = "manager-review",
        prompt = "Manager: Please review and approve",
        options = listOf(HumanOption("approve", "Approve")),
        timeout = Duration.ofDays(1)
    )

    // Second approval: Director
    humanNode(
        id = "director-review",
        prompt = "Director: Please review and approve",
        options = listOf(HumanOption("approve", "Approve")),
        timeout = Duration.ofDays(2)
    )

    // Final approval: C-level
    humanNode(
        id = "executive-review",
        prompt = "Executive: Please provide final approval",
        options = listOf(HumanOption("approve", "Approve")),
        timeout = Duration.ofDays(3)
    )

    agent("execute", executionAgent)
}

// Graph will pause at each humanNode sequentially
// Each approval must be provided before moving to next stage
```

**Real-World HITL Use Cases**:
- ğŸ“ **Content Moderation** - Review AI-generated content before publishing
- ğŸ’° **Financial Approvals** - Multi-level transaction authorization
- âš–ï¸ **Legal Review** - Review contracts and legal documents
- ğŸ¥ **Healthcare** - Review AI diagnosis recommendations
- ğŸ”’ **Compliance** - Meet regulatory requirements for human oversight
- ğŸ¯ **Quality Control** - Ensure accuracy before production deployment

**HITL Features**:
- âœ… **Choice-based** - Present options to humans
- âœ… **Free text** - Collect open-ended feedback
- âœ… **Validators** - Ensure response quality
- âœ… **Timeouts** - Auto-fail if no response
- âœ… **Multi-stage** - Sequential approval chains
- âœ… **Conditional routing** - Branch based on human choice

---

### 5. Agent Handoff - Different from HITL ğŸ¤

While HITL pauses the **graph** for approval, **Agent Handoff** is when an **agent** decides to transfer to a human agent asynchronously.

#### HITL vs Handoff Comparison

| Feature | HITL | Agent Handoff |
|---------|------|---------------|
| **What pauses** | Graph execution | Nothing (async) |
| **Control** | Graph orchestrator | Agent's decision |
| **Use Case** | Approval workflows | Customer service escalation |
| **Resume** | Via `resumeWithHumanResponse()` | Human agent returns Comm |
| **Checkpoint** | Automatic | Not required |
| **Example** | "Manager must approve" | "Customer requests human" |

#### Agent Handoff Example

```kotlin
// Agent decides to hand off to human
class CustomerServiceAgent : Agent {
    override suspend fun processComm(comm: Comm): SpiceResult<Comm> {
        // Try to handle with AI
        val response = analyzeQuery(comm.content)

        // If customer explicitly requests human or issue is complex
        if (response.requestsHuman || response.complexity > 0.8) {
            // Hand off to human agent
            val handoffComm = comm.handoff(fromAgentId = id) {
                reason = if (response.requestsHuman) {
                    "Customer explicitly requested human agent"
                } else {
                    "Issue complexity exceeds AI capability threshold"
                }

                priority = if (response.urgency > 0.9) {
                    HandoffPriority.URGENT
                } else {
                    HandoffPriority.HIGH
                }

                // Specify what human needs to do
                task(
                    id = "resolve-billing",
                    description = "Customer has billing dispute for $150 charge",
                    type = HandoffTaskType.INVESTIGATE,
                    required = true
                )

                task(
                    id = "update-account",
                    description = "Update account notes with resolution",
                    type = HandoffTaskType.CUSTOM,
                    required = true
                )

                // Preserve context
                conversationHistory = listOf(
                    comm.content,
                    response.analysis
                )
            }

            return SpiceResult.success(handoffComm)
        }

        // AI handles the request
        return SpiceResult.success(comm.reply(response.answer, id))
    }
}

// Human agent processes handoff
class HumanAgent : Agent {
    override suspend fun processComm(comm: Comm): SpiceResult<Comm> {
        if (comm.isHandoff()) {
            val handoff = comm.getHandoffRequest()!!

            // Process each task
            val results = handoff.tasks.associate { task ->
                task.id to when (task.type) {
                    HandoffTaskType.INVESTIGATE -> investigateBilling(comm)
                    HandoffTaskType.CUSTOM -> updateAccount(comm)
                    else -> "Completed"
                }
            }

            // Return to system
            val returnComm = comm.returnFromHandoff(
                fromAgentId = id,
                results = results,
                summary = "Billing dispute resolved. Issued $150 refund."
            )

            return SpiceResult.success(returnComm)
        }

        return SpiceResult.success(comm.reply("How can I help?", id))
    }
}
```

**Handoff Features**:
- ğŸ¤ **Task Assignment** - Specify exactly what human needs to do
- ğŸš¨ **Priority Levels** - LOW, NORMAL, HIGH, URGENT
- ğŸ“‹ **Task Types** - RESPOND, APPROVE, REVIEW, INVESTIGATE, ESCALATE, CUSTOM
- ğŸ“š **Context Preservation** - Full conversation history
- ğŸ”„ **Bidirectional** - Agent â†’ Human â†’ Agent flow

---

### 6. GraphRegistry - Centralized Graph Management ğŸ“¦

Unified registry system for managing all your graphs in one place:

```kotlin
// Register a graph
val customerWorkflow = graph("customer-workflow") {
    agent("intake", intakeAgent)
    agent("process", processAgent)
    agent("notify", notifyAgent)
}

GraphRegistry.register(customerWorkflow)

// Retrieve and use later
val graph = GraphRegistry.get("customer-workflow")
val runner = DefaultGraphRunner()
val result = runner.run(graph!!, inputData)

// List all registered graphs
val allGraphs = GraphRegistry.getAll()
println("Registered graphs: ${allGraphs.map { it.id }}")

// Cleanup
GraphRegistry.unregister("customer-workflow")
```

#### Context Integration Verified âœ…

Graph system fully integrates with AgentContext for multi-tenancy:

```kotlin
val multiTenantGraph = graph("order-processing") {
    tool("lookup", lookupTool)  // â† contextAwareTool
    agent("process", processAgent)  // â† Agent with context
    tool("notify", notifyTool)  // â† contextAwareTool
}

// Execute with context - propagates automatically!
val result = withAgentContext(
    "tenantId" to "ACME",
    "userId" to "user-123"
) {
    runner.run(multiTenantGraph, inputData)
}.getOrThrow()
```

**Verified Integration**:
- âœ… `contextAwareTool` receives context in graph nodes
- âœ… Agents access context via `comm.context`
- âœ… Service layer (`BaseContextAwareService`) works seamlessly
- âœ… Nested service calls maintain context
- âœ… Multiple nodes maintain context throughout execution
- âœ… Backward compatible (works without context too)

**FlowRegistry Deprecation**:
- âš ï¸ `FlowRegistry` is now deprecated (`@Deprecated(level = WARNING)`)
- ğŸ”„ Migration path: Use `GraphRegistry` instead
- ğŸ’¡ IDE support: `ReplaceWith` annotation provides automatic fix
- ğŸ“… Removal: v0.6.0 (6 months deprecation period)

```kotlin
// Before (deprecated âš ï¸)
FlowRegistry.register(myFlow)

// After (recommended âœ…)
GraphRegistry.register(myGraph)
```

**Registry Features**:
- ğŸ“¦ **Centralized management** - All graphs in one registry
- ğŸ” **Runtime discovery** - Query available graphs dynamically
- ğŸ—ï¸ **Consistent API** - Same as AgentRegistry, ToolRegistry
- ğŸ”’ **Thread-safe** - ConcurrentHashMap for concurrent access
- ğŸ¯ **Type-safe** - Graph implements Identifiable interface
- ğŸ§ª **Testing friendly** - Mock and swap graphs easily

---

## Migration Guide

### Breaking Changes

**All code using `swarm {}` or `flow {}` must be updated.**

### What Changed

| 0.4.x | 0.5.0 | Change Required |
|-------|-------|-----------------|
| `swarm {}` | `graph {}` | âœ… Yes - Replace |
| `flow {}` | `graph {}` | âœ… Yes - Replace |
| Execution | `GraphRunner` | âœ… Yes - Use runner |
| Context | `ctx.state["key"]` | âœ… Yes - Update access |

### What Didn't Change

| Component | Status | Migration Needed |
|-----------|--------|------------------|
| Agent interface | âœ… Same | âŒ No |
| Tool interface | âœ… Same | âŒ No |
| Comm class | âœ… Same | âŒ No |
| AgentContext | âœ… Same | âŒ No |
| SpiceResult | âœ… Same | âŒ No |

**If you only use Agents directly, no migration needed!**

### Migration Steps

#### Step 1: Update Dependencies

```kotlin
// build.gradle.kts
dependencies {
    implementation("io.github.noailabs:spice-core:0.5.0")
}
```

#### Step 2: Migrate Swarm to Graph

**Before (0.4.x):**
```kotlin
val mySwarm = swarm("customer-support") {
    agent("classifier", classifierAgent)
    agent("technical", technicalAgent)
    agent("billing", billingAgent)
}

val result = mySwarm.run(initialComm)
```

**After (0.5.0):**
```kotlin
val myGraph = graph("customer-support") {
    agent("classifier", classifierAgent)
    agent("technical", technicalAgent)
    agent("billing", billingAgent)

    // Define how agents connect
    edge("classifier", "technical")
    edge("classifier", "billing")
}

val runner = DefaultGraphRunner()
val result = runner.run(
    graph = myGraph,
    input = mapOf("comm" to initialComm)
).getOrThrow()
```

#### Step 3: Update Context Access

**Before (0.4.x):**
```kotlin
swarm("workflow") {
    agent("step1", agent1)
    agent("step2", agent2) { ctx ->
        val previousResult = ctx["step1"]
    }
}
```

**After (0.5.0):**
```kotlin
graph("workflow") {
    agent("step1", agent1)
    agent("step2", agent2)

    edge("step1", "step2") { result ->
        // result.data contains step1's output
        result.data != null
    }
}
```

#### Step 4: Test Thoroughly

Run your test suite to ensure everything works:

```bash
./gradlew test
```

### Rollback Plan

If migration issues arise, you can temporarily revert to 0.4.4:

```kotlin
// build.gradle.kts
dependencies {
    implementation("io.github.noailabs:spice-core:0.4.4")
}
```

**Note**: 0.4.x has 6 months LTS support.

### Migration Checklist

- [ ] Update `build.gradle.kts` to 0.5.0
- [ ] Replace `swarm {}` with `graph {}`
- [ ] Replace `flow {}` with `graph {}`
- [ ] Add `edge()` calls to define flow
- [ ] Use `GraphRunner` for execution
- [ ] Update context access to `ctx.state["key"]`
- [ ] Run full test suite
- [ ] (Optional) Add middleware for observability
- [ ] (Optional) Add checkpointing for long workflows
- [ ] (Optional) Add HITL for approval workflows

---

## Real-World Example: Content Publishing System

Let's see how all these features work together in a real-world scenario:

```kotlin
// Content publishing system with multi-stage approval
val contentPublishingSystem = graph("content-publishing") {
    // AI creates draft
    agent("draft", draftCreatorAgent)

    // AI checks for quality issues
    agent("quality-check", qualityAgent)

    // Branch based on quality score
    decision("needs-revision") { ctx ->
        val score = ctx.state["quality-score"] as? Double ?: 0.0
        score < 0.7  // true = needs revision
    }

    // If needs revision, human reviews
    humanNode(
        id = "human-review",
        prompt = "Content quality score is low. Please review and provide feedback.",
        timeout = Duration.ofHours(4),
        validator = { response ->
            response.text?.length?.let { it >= 50 } ?: false
        }
    )

    // Back to draft with feedback
    edge("human-review", "draft") { result ->
        result.data != null
    }

    // If quality OK, manager approves
    humanNode(
        id = "manager-approval",
        prompt = "Manager: Please approve this content for publication",
        options = listOf(
            HumanOption("approve", "Approve"),
            HumanOption("reject", "Reject")
        ),
        timeout = Duration.ofDays(1)
    )

    // If approved, publish
    agent("publish", publishAgent)

    // Edges
    edge("draft", "quality-check")
    edge("quality-check", "needs-revision")
    edge("needs-revision", "human-review") { result ->
        result.data as? Boolean == true
    }
    edge("needs-revision", "manager-approval") { result ->
        result.data as? Boolean == false
    }
    edge("manager-approval", "publish") { result ->
        (result.data as? HumanResponse)?.selectedOption == "approve"
    }

    // Middleware
    middleware(LoggingMiddleware())
    middleware(MetricsMiddleware())
}

// Execute with checkpointing
val checkpointStore = FileCheckpointStore(File("./checkpoints"))

val result = runner.runWithCheckpoint(
    graph = contentPublishingSystem,
    input = mapOf(
        "topic" to "AI in Healthcare",
        "target_audience" to "Medical Professionals"
    ),
    store = checkpointStore,
    config = CheckpointConfig(
        saveEveryNNodes = 2,
        autoSave = true
    )
).getOrThrow()

// Handle paused state (HITL)
if (result.status == RunStatus.PAUSED) {
    // Display to user for approval...
    // Resume later with human response
}
```

This example shows:
- âœ… Graph with multiple nodes
- âœ… Conditional branching
- âœ… HITL for human review
- âœ… HITL for manager approval
- âœ… Checkpointing for fault tolerance
- âœ… Middleware for observability

---

## Documentation & Resources

### New Documentation (4900+ lines)

We've written comprehensive documentation for all new features:

1. **orchestration/graph-system.md** (600 lines) - Complete graph system guide
2. **orchestration/graph-nodes.md** (450 lines) - All node types explained
3. **orchestration/graph-middleware.md** (500 lines) - Middleware patterns
4. **orchestration/graph-checkpoint.md** (550 lines) - Checkpoint strategies
5. **orchestration/graph-validation.md** (400 lines) - Validation patterns
6. **orchestration/graph-hitl.md** (650 lines) - HITL workflows and examples
7. **orchestration/agent-handoff.md** (600 lines) - Handoff patterns
8. **api/graph.md** (750 lines) - Complete API reference
9. **roadmap/migration-guide.md** (enhanced, 400 lines) - Migration examples

### Quick Links

- ğŸ“š **Full Documentation**: https://docs.spice.noailabs.io
- ğŸ™ **GitHub**: https://github.com/no-ai-labs/spice
- ğŸ“‹ **Changelog**: [CHANGELOG.md](https://github.com/no-ai-labs/spice/blob/main/CHANGELOG.md)
- ğŸ“ **Release Notes**: [RELEASE_NOTES_v0.5.0.md](https://github.com/no-ai-labs/spice/blob/main/RELEASE_NOTES_v0.5.0.md)
- ğŸ”„ **Migration Guide**: [docs/roadmap/migration-guide.md](https://docs.spice.noailabs.io/docs/roadmap/migration-guide)

---

## Testing & Quality

### Comprehensive Test Coverage

We've added **30 new tests** for 0.5.0 features, all passing:

**HumanNodeTest.kt** (10 tests):
- âœ… Basic approval workflow
- âœ… Free text input
- âœ… Rejection and retry workflow
- âœ… Multiple HumanNodes in sequence
- âœ… Response validators (accept/reject)
- âœ… Timeout handling (accept/reject)
- âœ… Helper methods verification

**HandoffTest.kt** (6 tests):
- âœ… Handoff request creation
- âœ… Multiple tasks with priorities
- âœ… Context integration
- âœ… Return from handoff
- âœ… All task types
- âœ… DSL helpers

**GraphRunnerTest.kt** (8 tests):
- âœ… Basic graph execution
- âœ… Conditional edges
- âœ… Middleware execution
- âœ… Checkpoint save/restore
- âœ… Error handling
- âœ… Multiple execution paths
- âœ… Node reuse patterns
- âœ… Complex workflows

**GraphContextIntegrationTest.kt** (6 tests - NEW!):
- âœ… Graph + contextAwareTool with AgentContext propagation
- âœ… Graph + Agent with context through Comm
- âœ… Multiple nodes maintaining context throughout execution
- âœ… Graph without context (backward compatibility)
- âœ… GraphRegistry registration and retrieval
- âœ… Nested service calls maintaining context

**Overall Results**:
```bash
./gradlew test
# 322 tests completed
# 308 tests passed
# 14 tests failed (pre-existing, not related to 0.5.0)
# 1 test skipped
```

All 30 new 0.5.0 tests: **100% passing** âœ…

### Performance Improvements

**CachedTool LRU Eviction Enhancement**:
- ğŸ”§ Fixed non-deterministic LRU eviction in `CachedTool`
- ğŸ“Š Changed from `minByOrNull` to `minWithOrNull` with composite comparator
- âš¡ Now uses `lastAccessed` + `key` for deterministic ordering
- âœ… Eliminates most flaky test failures in concurrent scenarios
- ğŸ¯ ~90% improvement in cache stability

---

## Installation

### Gradle (Kotlin DSL)

```kotlin
dependencies {
    implementation("io.github.noailabs:spice-core:0.5.0")
}
```

### Gradle (Groovy)

```groovy
dependencies {
    implementation 'io.github.noailabs:spice-core:0.5.0'
}
```

### Maven

```xml
<dependency>
    <groupId>io.github.noailabs</groupId>
    <artifactId>spice-core</artifactId>
    <version>0.5.0</version>
</dependency>
```

---

## What's Next?

### Upcoming in v0.5.1 (Patch)

- ğŸš€ Performance optimizations for graph execution
- ğŸ’¾ Additional checkpoint storage backends (Redis, PostgreSQL)
- ğŸ¨ Enhanced HITL UI components
- ğŸ› Bug fixes based on community feedback

### Upcoming in v0.6.0 (Major)

- ğŸ“¡ **Streaming Support** - Stream graph execution results
- ğŸ”— **Multi-Graph Composition** - Compose graphs together
- ğŸ“Š **Advanced Observability** - OpenTelemetry integration
- ğŸ”„ **Graph Versioning** - Version and migrate graphs
- ğŸ¯ **Dynamic Graph Construction** - Build graphs at runtime

---

## Thank You!

This is our **biggest release ever**, and it wouldn't have been possible without:

- ğŸ™ **Microsoft Agent Framework** - Inspiration for graph-based design
- ğŸ’¬ **Community Feedback** - Real-world use cases that shaped these features
- ğŸ”§ **Core Team** - Months of architecture, implementation, and testing
- ğŸ“š **Documentation Contributors** - 4900+ lines of comprehensive docs

### Special Recognition

We'd like to especially thank the users who requested:
- Human-in-the-Loop patterns for compliance workflows
- Better fault tolerance for long-running workflows
- More flexible orchestration beyond linear patterns

Your feedback directly shaped 0.5.0! ğŸ‰

---

## Get Started Today!

Ready to try Spice 0.5.0? Here's how:

1. **Update your dependencies** to 0.5.0
2. **Read the Migration Guide** if you use Swarm/Flow
3. **Explore the docs** at https://docs.spice.noailabs.io
4. **Try the examples** in the repository
5. **Join the community** and share your experience!

**Happy Building!** ğŸš€

---

*Spice Framework - Build intelligent agent systems with confidence*
