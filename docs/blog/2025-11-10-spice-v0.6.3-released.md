---
slug: spice-v0.6.3-released
title: Spice 0.6.3 Released - Breaking Free from DAGs
authors: [spice-team]
tags: [release, feature, graphs, cycles, workflows]
---

# Breaking Free from DAGs: Why We Added Cyclic Graphs to Spice

Sometimes, workflows need to loop. Sometimes, agents need to retry. Sometimes, you need to ask the user "Are you sure?" three times before they actually confirm.

Spice 0.6.3 introduces **optional cycle validation**, letting you build iterative workflows while maintaining safety through explicit opt-in.

<!-- truncate -->

## TL;DR

**Update now:**
```kotlin
implementation("com.github.no-ai-labs.spice-framework:spice-core:0.6.3")
```

**New feature:**
```kotlin
val graph = Graph(
    ...,
    allowCycles = true  // ‚≠ê Loop away!
)
```

---

## The Request: "Can I Make It Loop Until It's Good Enough?"

It started with a simple question in our GitHub issues:

> "I'm building a workflow that refines AI responses until they meet a quality threshold. Can I make a graph that loops back to the refine step?"

The short answer was: **No**. Spice graphs were strictly DAGs (Directed Acyclic Graphs). No cycles allowed.

The longer answer involved workarounds:
- Put the loop logic inside a single node (lose graph visibility)
- Use manual while loops (bye-bye checkpointing)
- Restructure your workflow to avoid loops (often awkward)

But the real question was: **Why not allow cycles when the user explicitly wants them?**

---

## The Philosophy: Safe by Default, Flexible When Needed

### Why DAGs by Default?

DAGs are great for most workflows:
- **Predictable execution** - Clear start and end
- **No infinite loops** - Can't accidentally create a loop
- **Easy to reason about** - Follow the arrows
- **Efficient validation** - Topological sort works

This makes sense for 90% of use cases:
```
Data Collection ‚Üí Processing ‚Üí Analysis ‚Üí Output
```

### But Some Workflows Are Inherently Cyclic

**Example 1: Iterative Refinement**

```
Generate Draft ‚Üí Check Quality
        ‚Üë              ‚Üì
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ Loop if bad
               ‚Üì
            Output if good
```

**Example 2: User Interaction**

```
Ask Question ‚Üí Validate Input
      ‚Üë              ‚Üì
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Retry if invalid
             ‚Üì
         Continue if valid
```

**Example 3: Retry with Backoff**

```
Call API ‚Üí Check Response
    ‚Üë           ‚Üì
    ‚îî‚îÄ‚îÄ‚îÄ Wait & Retry if failed
         ‚Üì
      Success if ok
```

These patterns are **natural loops**, not accidental cycles.

---

## The Design: Explicit Opt-In

We considered a few approaches:

### ‚ùå Option A: Allow All Cycles

```kotlin
val graph = Graph(...)  // Cycles allowed by default
```

**Problem:** Too risky. Users could accidentally create infinite loops.

### ‚ùå Option B: Detect "Safe" Loops

```kotlin
// Auto-detect safe loops with exit conditions
val graph = Graph(...)
```

**Problem:** How do we determine if an exit condition is "safe"? What if it depends on external state?

### ‚úÖ Option C: Explicit Opt-In (What We Chose)

```kotlin
val graph = Graph(
    ...,
    allowCycles = false  // Default: safe DAG
)

val loopGraph = Graph(
    ...,
    allowCycles = true  // Explicit: "I know what I'm doing"
)
```

**Why this works:**
- **Safe by default** - Existing code unchanged
- **Explicit intent** - You must opt-in
- **Clear responsibility** - Developer knows to add loop guards
- **Backward compatible** - No breaking changes

---

## Real-World Example: AI Content Refinement

Let's build a workflow that refines AI-generated content until it meets quality standards:

### The Workflow

```kotlin
val refinementWorkflow = graph("content-refinement") {
    // Generate initial draft
    agent("generate", generateAgent)

    // Check quality metrics
    agent("evaluate", evaluationAgent)

    // Refine if needed
    agent("refine", refinementAgent)

    // Final output
    output("result") { it.state["refine"] ?: it.state["generate"] }

    edges {
        // Initial generation
        edge("generate", "evaluate")

        // Loop back if quality insufficient
        edge("evaluate", "refine") { result ->
            val comm = result.metadata["_previousComm"] as? Comm
            val quality = comm?.data?.get("quality_score")?.toDoubleOrNull() ?: 0.0
            val iterations = ctx.state["iterations"] as? Int ?: 0

            // Loop condition: quality < 0.9 AND iterations < 10
            quality < 0.9 && iterations < 10  // ‚≠ê Safety guard
        }

        // Refine and re-evaluate
        edge("refine", "evaluate")

        // Exit when quality sufficient
        edge("evaluate", "result") { result ->
            val comm = result.metadata["_previousComm"] as? Comm
            val quality = comm?.data?.get("quality_score")?.toDoubleOrNull() ?: 0.0
            quality >= 0.9  // Exit condition
        }
    }

    allowCycles = true  // ‚≠ê Enable loops
}
```

### Execution Flow

**Input:** "Write a blog post about AI"

**Iteration 1:**
```
generate ‚Üí evaluate
  Quality: 0.6 (< 0.9)
  ‚Üí Loop to refine
```

**Iteration 2:**
```
refine ‚Üí evaluate
  Quality: 0.75 (< 0.9)
  ‚Üí Loop to refine
```

**Iteration 3:**
```
refine ‚Üí evaluate
  Quality: 0.92 (>= 0.9)
  ‚Üí Exit to result ‚úÖ
```

**Result:** High-quality blog post after 3 iterations!

---

## Safety First: Preventing Infinite Loops

When you set `allowCycles = true`, **you're responsible for preventing infinite loops**. Here are the key strategies:

### 1. Iteration Counters

**Always** track loop iterations and set a maximum:

```kotlin
edge("process", "process") { result ->
    val iterations = ctx.state["iterations"] as? Int ?: 0
    val shouldContinue = checkCondition(result)

    shouldContinue && iterations < MAX_ITERATIONS  // ‚≠ê Safety guard
}
```

### 2. Timeout Middleware

Add graph-level timeout protection:

```kotlin
class TimeoutMiddleware(val maxDuration: Duration) : Middleware {
    override suspend fun onStart(ctx: RunContext, next: suspend () -> Unit) {
        withTimeout(maxDuration.toMillis()) {
            next()
        }
    }
}

val graph = Graph(
    ...,
    middleware = listOf(TimeoutMiddleware(Duration.ofMinutes(5))),
    allowCycles = true
)
```

### 3. Multiple Exit Conditions

Never rely on a single exit condition - add redundant guards:

```kotlin
edge("retry", "retry") { result ->
    val shouldRetry = result.data == "retry"
    val retries = ctx.state["retries"] as? Int ?: 0
    val elapsed = Duration.between(startTime, Instant.now())

    // ‚úÖ Multiple guards
    shouldRetry && retries < 5 && elapsed < Duration.ofMinutes(2)
}
```

### 4. State-Based Guards

Use state to track progress and prevent stalls:

```kotlin
edge("process", "process") { result ->
    val prevQuality = ctx.state["prev_quality"] as? Double ?: 0.0
    val currQuality = result.data as? Double ?: 0.0

    // Only loop if making progress
    currQuality > prevQuality && currQuality < TARGET_QUALITY
}
```

---

## Use Cases in the Wild

Here are real workflows that benefit from cyclic graphs:

### 1. Chatbot Clarification Loop

```kotlin
val chatbotGraph = graph("chatbot-clarification") {
    agent("understand", intentAgent)
    agent("clarify", clarificationAgent)
    human("confirm", prompt = "Is this correct?")
    agent("execute", executionAgent)

    edges {
        edge("understand", "clarify") { lowConfidence(it) }
        edge("understand", "confirm") { highConfidence(it) }

        edge("clarify", "confirm")

        edge("confirm", "understand") { result ->
            // Loop if user says "no"
            (result.data as? HumanResponse)?.approved != true
        }

        edge("confirm", "execute") { result ->
            // Exit if user confirms
            (result.data as? HumanResponse)?.approved == true
        }
    }

    allowCycles = true
}
```

### 2. API Retry with Exponential Backoff

```kotlin
val apiRetryGraph = graph("api-retry") {
    agent("call-api", apiAgent)
    agent("check-status", statusCheckAgent)
    agent("backoff", backoffAgent)
    output("success") { it.state["call-api"] }

    edges {
        edge("call-api", "check-status")

        edge("check-status", "success") { isSuccess(it) }

        edge("check-status", "backoff") { result ->
            val retries = ctx.state["retries"] as? Int ?: 0
            !isSuccess(result) && retries < 5
        }

        edge("backoff", "call-api")  // Loop back
    }

    allowCycles = true
}
```

### 3. Data Validation Loop

```kotlin
val validationGraph = graph("data-validation") {
    agent("validate", validationAgent)
    human("fix", prompt = "Please fix the following errors:")
    agent("revalidate", revalidationAgent)
    output("clean-data") { it.state["validate"] }

    edges {
        edge("validate", "clean-data") { isValid(it) }

        edge("validate", "fix") { !isValid(it) }

        edge("fix", "revalidate")

        edge("revalidate", "clean-data") { isValid(it) }

        edge("revalidate", "fix") { result ->
            val attempts = ctx.state["fix_attempts"] as? Int ?: 0
            !isValid(result) && attempts < 3
        }
    }

    allowCycles = true
}
```

---

## Technical Deep Dive: How Validation Changed

### Before 0.6.3: Strict DAG Enforcement

```kotlin
// GraphValidator.kt (0.6.2)
fun validate(graph: Graph): SpiceResult<Unit> {
    // ... other checks ...

    // Always check for cycles
    val cycleNodes = detectCycles(graph)
    if (cycleNodes.isNotEmpty()) {
        errors.add("Graph contains cycles involving nodes: ${cycleNodes.joinToString(", ")}")
    }

    // ...
}
```

**Result:** Any cycle ‚Üí Validation failure

### After 0.6.3: Conditional Cycle Check

```kotlin
// GraphValidator.kt (0.6.3)
fun validate(graph: Graph): SpiceResult<Unit> {
    // ... other checks ...

    // Only check for cycles if not explicitly allowed
    if (!graph.allowCycles) {  // ‚≠ê New condition
        val cycleNodes = detectCycles(graph)
        if (cycleNodes.isNotEmpty()) {
            errors.add("Graph contains cycles involving nodes: ${cycleNodes.joinToString(", ")}")
        }
    }

    // ...
}
```

**Result:**
- `allowCycles = false` (default) ‚Üí Cycle check runs (safe DAG)
- `allowCycles = true` ‚Üí Cycle check skipped (loops allowed)

### Graph.isDAG() Unchanged

Importantly, `GraphValidator.isDAG()` still works correctly:

```kotlin
val cyclicGraph = Graph(
    id = "loop",
    nodes = mapOf("a" to node),
    edges = listOf(Edge("a", "a")),
    entryPoint = "a",
    allowCycles = true
)

GraphValidator.validate(cyclicGraph).isSuccess  // true ‚úÖ (validation passes)
GraphValidator.isDAG(cyclicGraph)  // false (correctly identifies non-DAG)
```

This lets you check graph topology independent of validation policy.

---

## Testing: How We Verified Safety

### New Test Cases

```kotlin
@Test
fun `test cyclic graph passes validation when allowCycles is true`() {
    val graph = Graph(
        id = "allowed-cyclic",
        nodes = mapOf(
            "a" to OutputNode("a"),
            "b" to OutputNode("b"),
            "c" to OutputNode("c")
        ),
        edges = listOf(
            Edge("a", "b"),
            Edge("b", "c"),
            Edge("c", "a")  // Cycle!
        ),
        entryPoint = "a",
        allowCycles = true
    )

    val result = GraphValidator.validate(graph)

    assertTrue(result.isSuccess)  // Passes!
    assertFalse(GraphValidator.isDAG(graph))  // Still not a DAG
}

@Test
fun `test self-loop passes validation when allowCycles is true`() {
    val graph = Graph(
        id = "self-loop",
        nodes = mapOf(
            "workflow" to workflowNode,
            "response" to responseNode
        ),
        edges = listOf(
            Edge("workflow", "workflow") { shouldContinue(it) },
            Edge("workflow", "response") { shouldExit(it) }
        ),
        entryPoint = "workflow",
        allowCycles = true
    )

    val result = GraphValidator.validate(graph)

    assertTrue(result.isSuccess)
}
```

**All tests passed:** 11/11 ‚úÖ

---

## Best Practices for Cyclic Graphs

### ‚úÖ Do's

1. **Always add iteration counters**
   ```kotlin
   val iterations = ctx.state["iterations"] as? Int ?: 0
   shouldLoop && iterations < MAX_ITERATIONS
   ```

2. **Use timeout middleware**
   ```kotlin
   middleware = listOf(TimeoutMiddleware(Duration.ofMinutes(5)))
   ```

3. **Implement multiple exit conditions**
   ```kotlin
   shouldRetry && retries < 5 && elapsed < timeout
   ```

4. **Track progress to detect stalls**
   ```kotlin
   val progress = currValue - prevValue
   shouldLoop && progress > MIN_PROGRESS
   ```

5. **Test loop termination thoroughly**
   ```kotlin
   @Test
   fun `test loop exits after max iterations`() {
       // ... verify loop stops
   }
   ```

### ‚ùå Don'ts

1. **Don't rely on single exit condition**
   ```kotlin
   // ‚ùå DANGEROUS
   edge("node", "node") { result.data == "retry" }
   ```

2. **Don't allow unbounded loops**
   ```kotlin
   // ‚ùå NO GUARDS
   edge("node", "node") { shouldContinue(it) }
   ```

3. **Don't ignore middleware timeout errors**
   ```kotlin
   // ‚ùå Don't catch and suppress
   try { runner.run(graph, input) }
   catch (e: TimeoutException) { /* ignore */ }
   ```

4. **Don't skip checkpointing for long loops**
   ```kotlin
   // ‚úÖ Enable checkpointing
   runner.runWithCheckpoint(graph, input, store, config)
   ```

---

## Migration: Upgrading from 0.6.2

### Step 1: Update Dependency

```kotlin
// build.gradle.kts
dependencies {
    implementation("com.github.no-ai-labs.spice-framework:spice-core:0.6.3")
}
```

### Step 2: Enable Cycles Where Needed

```kotlin
// Before: Manual workaround or error
val graph = Graph(...)
// Would fail validation if had cycles

// After: Explicit opt-in
val graph = Graph(
    ...,
    allowCycles = true
)
```

### Step 3: Add Safety Guards

```kotlin
// Add iteration counters
edge("process", "process") { result ->
    val iterations = ctx.state["iterations"] as? Int ?: 0
    shouldContinue(result) && iterations < 10
}

// Add timeout middleware
Graph(
    ...,
    middleware = listOf(TimeoutMiddleware(Duration.ofMinutes(5))),
    allowCycles = true
)
```

**100% backward compatible** - existing DAG workflows unchanged!

---

## What's Next?

We're already working on 0.7.0 with exciting new features:

### Parallel Execution (Coming Soon!)

Execute multiple branches in parallel and merge results:

```kotlin
val parallelGraph = graph("parallel-processing") {
    parallel("data-processing") {
        branch("fetch", fetchNode)
        branch("validate", validateNode)
        branch("transform", transformNode)
    }

    merge("aggregate") { results ->
        combineResults(results)
    }
}
```

### Advanced Merge Strategies

```kotlin
parallel("analysis") {
    branch("llm-a", openAIAgent)
    branch("llm-b", claudeAgent)
    branch("llm-c", geminiAgent)

    mergePolicy = MergePolicy.Vote  // Pick most common answer
    // or
    mergePolicy = MergePolicy.Average  // Average confidence scores
}
```

Stay tuned!

---

## Get Started

```kotlin
// build.gradle.kts
dependencies {
    implementation("com.github.no-ai-labs.spice-framework:spice-core:0.6.3")
}
```

**Resources:**
- [Graph Validation Docs](/docs/orchestration/graph-validation)
- [Release Notes](/RELEASE_NOTES_v0.6.3.md)
- [GitHub](https://github.com/no-ai-labs/spice-framework)

---

**Questions? Found a bug? Have feedback?**

- Open an issue: [GitHub Issues](https://github.com/no-ai-labs/spice-framework/issues)
- Check the docs: [spice-framework.dev](https://spice-framework.dev)

**Happy looping! üå∂Ô∏è**

*- The Spice Team*
