---
slug: spice-v0.8.1-released
title: Spice 0.8.1 Released - Critical HITL Metadata Propagation Fix
authors: [spice-team]
tags: [release, bugfix, hitl, human-in-the-loop, context-propagation]
---

# Your Agent Just Lost User's Selection Data. Here's Why.

You built a beautiful HITL workflow: Agent â†’ HumanNode â†’ Agent. User selects an item. Next agent runs... and can't find the selection.

**Wait, where did the data go?** ğŸ¤”

Spice 0.8.1 fixes a critical bug where `HumanResponse.metadata` wasn't propagating to the next agent. Update now.

<!-- truncate -->

## TL;DR

**Update immediately if you use HumanNode with metadata:**
```kotlin
implementation("com.github.no-ai-labs.spice-framework:spice-core:0.8.1")
```

**What was broken:**
```kotlin
// Step 1: Agent generates data
comm.reply("Menu ready", id, data = mapOf(
    "items_json" to "[...]",
    "session_id" to "SESSION123"
))

// Step 2: Graph pauses at HumanNode
// Step 3: User responds with metadata
val response = HumanResponse(
    nodeId = "select",
    metadata = mapOf("selected_id" to "ITEM002")  // ğŸ”¥
)

// Step 4: Resume...
runner.resumeWithHumanResponse(...)

// Step 5: Next agent runs
comm.context?.get("selected_id")  // âŒ null (before 0.8.1)
```

**What's fixed:**
```kotlin
comm.context?.get("selected_id")  // âœ… "ITEM002" (after 0.8.1)
```

**Zero breaking changes.** Just update and it works.

---

## The Bug: Silent Data Loss

### Scenario

You're building a reservation cancellation workflow:

```kotlin
val graph = graph("cancel-reservation") {
    // Agent fetches reservations
    agent("list", listAgent)

    // User selects one
    dynamicHumanNode("select", promptKey = "menu_text")

    // Agent cancels it
    agent("cancel", cancelAgent)  // âŒ Can't find selected reservation!
}
```

### The Symptom

```kotlin
class CancelReservationAgent : Agent {
    override suspend fun processComm(comm: Comm): SpiceResult<Comm> {
        // Try to get selected reservation ID
        val selectedId = comm.context?.get("selected_reservation_id")
        // âŒ null! Where did it go??

        val reservationsJson = comm.context?.get("reservations_json")
        // âœ… This works fine (from first agent)
    }
}
```

**What happened?**
- First agent's data (`reservations_json`) âœ… Works
- HumanResponse metadata (`selected_reservation_id`) âŒ Lost

---

## The Root Cause

In `GraphRunner.resumeWithHumanResponse()`, `HumanResponse` was stored in **state only**:

```kotlin
// Before 0.8.1 (BROKEN)
nodeContext = nodeContext
    .withState(checkpoint.currentNodeId, response)
    .withState("_previous", response)
// âŒ HumanResponse.metadata never merged into ExecutionContext!

val currentResult = NodeResult.fromContext(ctx, data = response)
// âŒ Metadata not included!
```

**Result:** Next agent's `comm.context` didn't have HumanResponse data.

### Why This Matters

ExecutionContext is the **single source of truth** for all metadata in Spice 0.6.0+. AgentNode reads from `comm.context` (which comes from ExecutionContext).

**Standard flow:**
```
Agent â†’ result.metadata â†’ ExecutionContext â†’ comm.context â†’ Next Agent âœ…
```

**Broken flow:**
```
HumanResponse â†’ result.data â†’ NodeContext.state â†’ âŒ Lost
```

---

## The Fix

### Code Changes

```kotlin
// After 0.8.1 (FIXED)
val humanMetadata = response.metadata.mapValues { it.value as Any }

nodeContext = nodeContext
    .withState(checkpoint.currentNodeId, response)
    .withState("_previous", response)
    .withContext(nodeContext.context.plusAll(humanMetadata))  // ğŸ”¥ NEW!

val currentResult = NodeResult.fromContext(
    ctx = nodeContext,
    data = response,
    additional = humanMetadata  // ğŸ”¥ Explicitly propagated
)
```

**What this does:**
1. Extract metadata from HumanResponse
2. Merge into ExecutionContext
3. Include in NodeResult metadata
4. Next agent receives it via `comm.context`

### New Helper Function

We added `NodeResult.fromHumanResponse()` for convenience:

```kotlin
// Recommended pattern
val result = NodeResult.fromHumanResponse(ctx, response)

// Equivalent to:
val humanMetadata = response.metadata.mapValues { it.value as Any }
val result = NodeResult.fromContext(ctx, response, additional = humanMetadata)
```

---

## Full Context Flow (After Fix)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. First Agent                       â”‚
â”‚    comm.data = {"items_json": "..."}â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. GraphRunner                       â”‚
â”‚    ctx.context += result.metadata   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. Checkpoint                        â”‚
â”‚    checkpoint.metadata = ctx.contextâ”‚
â”‚    Saved: items_json                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“ [PAUSE]
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. Resume                            â”‚
â”‚    ctx.context restored from ckpt   â”‚
â”‚    Has: items_json âœ…                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. Merge HumanResponse (NEW!)       â”‚
â”‚    ctx.context += response.metadata â”‚
â”‚    Has: items_json, selected_id âœ…  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. Next Agent                        â”‚
â”‚    comm.context has everything! âœ…  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Example: Before vs. After

### Before 0.8.1 (Broken Workaround)

```kotlin
// Had to manually extract from state
class CancelAgent : Agent {
    override suspend fun processComm(comm: Comm): SpiceResult<Comm> {
        // âŒ Ugly workaround: read from state
        val response = getStateFromSomewhere()["_previous"] as HumanResponse
        val selectedId = response.metadata["selected_id"]

        // Still need reservations_json from context
        val reservationsJson = comm.context?.get("reservations_json")

        // Process...
    }
}
```

**Problems:**
- Manual state extraction
- No type safety
- Breaks abstraction
- Doesn't work with checkpoint restore

### After 0.8.1 (Fixed)

```kotlin
// Clean context access
class CancelAgent : Agent {
    override suspend fun processComm(comm: Comm): SpiceResult<Comm> {
        // âœ… Everything in context!
        val selectedId = comm.context?.get("selected_id")
        val reservationsJson = comm.context?.get("reservations_json")

        // Process naturally
        return cancelReservation(selectedId, reservationsJson)
    }
}
```

**Benefits:**
- âœ… Consistent pattern (same as regular agent flows)
- âœ… Type-safe via ExecutionContext
- âœ… Works with checkpoint/resume
- âœ… Zero boilerplate

---

## Migration Guide

### No Action Required

This is a **transparent fix**. Existing code continues to work. But if you were using workarounds, you can clean them up:

**Remove workarounds like:**
```kotlin
// âŒ Delete this:
val humanResponse = ctx.state["_previous"] as? HumanResponse
val selectedId = humanResponse?.metadata?.get("selected_id")

// âœ… Use this instead:
val selectedId = comm.context?.get("selected_id")
```

### Recommended: Add Metadata to HumanResponse

If you're building HITL workflows, pass user selections via metadata:

```kotlin
// In your UI handler:
val response = HumanResponse(
    nodeId = "select-item",
    selectedOption = "option-2",
    metadata = mapOf(
        "selected_id" to "ITEM002",
        "selected_name" to "Premium Plan",
        "user_notes" to "Need rush delivery"
    )
)

runner.resumeWithHumanResponse(graph, checkpointId, response, store)

// Next agent automatically receives all metadata via comm.context âœ…
```

---

## Testing

### New Test Coverage

Added comprehensive test:
```kotlin
@Test
fun `test HumanResponse metadata propagates to next AgentNode via ExecutionContext`()
```

**Validates:**
1. First agent generates data with `comm.data`
2. Checkpoint saves context
3. Resume with HumanResponse containing metadata
4. Next agent receives **both** original context and HumanResponse metadata

### All Tests Passing

- âœ… HumanNodeTest: 11 tests
- âœ… DynamicHumanNodeTest: 10 tests
- âœ… CheckpointIntegrationTest: 6 tests
- âœ… New metadata propagation test

---

## What We Learned

### Architecture Alignment

This bug exposed a deviation from Spice 0.6.0's ExecutionContext unification principle:

> "í•­ìƒ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ëŠ” ExecutionContextë¥¼ ë‹¨ì¼ ì†ŒìŠ¤ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤."

**AgentNode** already followed this pattern:
```kotlin
// AgentNode properly merges context
val contextData = ctx.context.toMap()
val mergedData = contextData + previousData
comm.data = mergedData  // âœ… Full context propagated
```

**GraphRunner.resumeWithHumanResponse()** didn't:
```kotlin
// Was missing context merge
nodeContext.withState(response)  // âŒ State only
```

**Now aligned:**
```kotlin
// Now merges into context
nodeContext.withContext(ctx.context.plusAll(humanMetadata))  // âœ…
```

### Design Principle

**Metadata Propagation Rule:**
> Any data that subsequent nodes need **must** flow through ExecutionContext.

This ensures:
- Checkpoint/resume works seamlessly
- AgentNode can access via `comm.context`
- Consistent with framework design

---

## Upgrade Instructions

### Gradle (JitPack)
```kotlin
dependencies {
    implementation("com.github.no-ai-labs.spice-framework:spice-core:0.8.1")
}
```

### Maven
```xml
<dependency>
    <groupId>com.github.no-ai-labs.spice-framework</groupId>
    <artifactId>spice-core</artifactId>
    <version>0.8.1</version>
</dependency>
```

**No code changes required.** Just update and it works.

---

## Documentation

**Updated Docs:**
- [HITL Guide - Metadata Propagation](/docs/orchestration/graph-hitl#metadata-propagation-081)
- [Full Release Notes](/RELEASE_NOTES_v0.8.1.md)
- [ExecutionContext API](/docs/api/execution-context)

**CLAUDE.md:**
- Added "HumanResponse Metadata ì „íŒŒ (0.8.1+)" section
- Documented `NodeResult.fromHumanResponse()` helper
- Added test patterns for metadata validation

---

## Next Steps

**v0.9.0 Preview:**
- Enhanced parallel execution with nested graphs
- Multi-agent coordination patterns
- Advanced retry strategies

**v1.0.0 Roadmap:**
- Production stability guarantees
- Performance benchmarks
- Enterprise support

---

## Join the Community

- ğŸ› [Report Issues](https://github.com/no-ai-labs/spice/issues)
- ğŸ’¬ [Discussions](https://github.com/no-ai-labs/spice/discussions)
- ğŸ“– [Documentation](https://spice-framework.dev)

**Update now and never lose user data again!** ğŸŒ¶ï¸âœ¨
