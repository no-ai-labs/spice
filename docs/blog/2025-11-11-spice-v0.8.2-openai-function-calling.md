---
slug: spice-v0.8.2-openai-function-calling
title: Spice 0.8.2 - One Line to OpenAI Function Calling
authors: [spice-team]
tags: [release, openai, function-calling, tools, integration, llm]
---

# Stop Writing OpenAI Function Specs by Hand

You defined your tool once. In Spice. With perfect schema and validation.

Now you need it in OpenAI format. Again. Manually. Copy-paste. JSON. Hope you didn't miss anything.

**There's a better way.** ‚ú®

```kotlin
val openAISpec = myTool.toOpenAIFunctionSpec()  // That's it.
```

Spice 0.8.2 adds first-class OpenAI Function Calling support. Define once, use everywhere.

<!-- truncate -->

## TL;DR

**Update now:**
```kotlin
implementation("com.github.no-ai-labs.spice-framework:spice-core:0.8.2")
```

**Convert any Spice tool to OpenAI format:**
```kotlin
// Your Spice tool
val searchTool = WebSearchTool()

// OpenAI function spec (one line!)
val openAISpec = searchTool.toOpenAIFunctionSpec()

// Use with OpenAI API
val chatRequest = ChatCompletionRequest(
    model = ModelId("gpt-5"),
    messages = messages,
    functions = listOf(openAISpec)  // ‚úÖ Ready to go
)
```

**Zero breaking changes.** New extension functions only.

---

## The Problem: Tool Definition Hell

You're building an AI-powered app. You need tools. Lots of tools.

### Scenario 1: Duplicate Definitions

```kotlin
// Your Spice tool (version 1)
class WebSearchTool : BaseTool() {
    override val name = "web_search"
    override val description = "Search the web for information"
    override val schema = ToolSchema(
        name = name,
        description = description,
        parameters = mapOf(
            "query" to ParameterSchema("string", "Search query", required = true),
            "limit" to ParameterSchema("number", "Max results", required = false)
        )
    )
    // ... implementation
}

// Your OpenAI function spec (version 2) üò±
val openAIFunction = mapOf(
    "name" to "web_search",
    "description" to "Search the web for information",
    "parameters" to mapOf(
        "type" to "object",
        "properties" to mapOf(
            "query" to mapOf(
                "type" to "string",
                "description" to "Search query"
            ),
            "limit" to mapOf(
                "type" to "number",
                "description" to "Max results"
            )
        ),
        "required" to listOf("query")
    )
)
```

**Problems:**
- ‚ùå Two sources of truth
- ‚ùå Manual JSON construction
- ‚ùå Easy to desync
- ‚ùå No type safety
- ‚ùå Tedious to maintain

### Scenario 2: WorkflowTool Boilerplate

```kotlin
// Before 0.8.2: Manual conversion everywhere
class WorkflowTool(val spiceTool: Tool) {
    fun toOpenAISpec(): Map<String, Any> {
        // 50 lines of boilerplate...
        return mapOf(
            "name" to spiceTool.name,
            "description" to spiceTool.description,
            "parameters" to mapOf(
                "type" to "object",
                "properties" to spiceTool.schema.parameters.mapValues { (_, param) ->
                    mapOf(
                        "type" to param.type,
                        "description" to param.description
                    )
                },
                "required" to spiceTool.schema.parameters
                    .filter { it.value.required }
                    .keys
                    .toList()
            )
        )
    }
}
```

You wrote this. You copy-pasted it. You debugged it. You hate it.

---

## The Solution: Built-In Conversion

### One Extension Function

```kotlin
// Spice 0.8.2
fun Tool.toOpenAIFunctionSpec(): Map<String, Any>
fun ToolSchema.toOpenAIFunctionSpec(): Map<String, Any>
```

That's it. That's the whole API.

### Real-World Example

```kotlin
// Define your tool once
val databaseTool = SimpleTool(
    name = "query_database",
    description = "Execute SQL queries on the customer database",
    parameterSchemas = mapOf(
        "query" to ParameterSchema(
            "string",
            "SQL query to execute (SELECT only)",
            required = true
        ),
        "limit" to ParameterSchema(
            "number",
            "Maximum rows to return (1-1000)",
            required = false
        )
    )
) { params ->
    val query = params["query"] as String
    val limit = (params["limit"] as? Number)?.toInt() ?: 100

    val results = database.execute(query, limit)
    ToolResult.success(results.toJson())
}

// Use with Spice agents (native)
val spiceAgent = buildAgent {
    name = "Database Agent"
    tools { tool(databaseTool) }
}

// Use with OpenAI (one line!)
val openAISpec = databaseTool.toOpenAIFunctionSpec()
```

**Output:**
```json
{
  "type": "function",
  "name": "query_database",
  "description": "Execute SQL queries on the customer database",
  "parameters": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "SQL query to execute (SELECT only)"
      },
      "limit": {
        "type": "number",
        "description": "Maximum rows to return (1-1000)"
      }
    },
    "required": ["query"]
  }
}
```

**Perfect OpenAI format. Zero manual work.** ‚ú®

### Strict Mode Support

Need production-grade schema validation? Enable strict mode:

```kotlin
// Development: flexible, non-strict (default)
val spec = tool.toOpenAIFunctionSpec()

// Production: strict validation
val strictSpec = tool.toOpenAIFunctionSpec(strict = true)
```

**Strict Mode Output:**
```json
{
  "type": "function",
  "name": "query_database",
  "description": "Execute SQL queries on the customer database",
  "parameters": {
    "type": "object",
    "properties": { ... },
    "required": ["query"],
    "additionalProperties": false
  },
  "strict": true
}
```

**Perfect for:**
- ‚úÖ Production APIs with strict contracts
- ‚úÖ Type-safe function calling
- ‚úÖ Preventing unexpected properties

---

## Real-World Use Cases

### 1. Multi-Provider AI Application

Build once, deploy everywhere:

```kotlin
// Define tools once
val tools = listOf(
    WebSearchTool(),
    DatabaseQueryTool(dataSource),
    EmailSenderTool(smtpConfig),
    SlackNotifierTool(slackClient)
)

// Use with Spice (local execution)
val spiceAgent = buildAgent {
    name = "Local Agent"
    tools {
        tools.forEach { tool(it) }
    }
}

// Use with OpenAI (remote execution)
val openAIFunctions = tools.map { it.toOpenAIFunctionSpec() }

val chatRequest = ChatCompletionRequest(
    model = ModelId("gpt-4"),
    messages = listOf(
        ChatMessage(
            role = ChatRole.User,
            content = "Search for customer data and send summary via Slack"
        )
    ),
    functions = openAIFunctions  // All your tools, instantly available
)

val response = openAI.chatCompletion(chatRequest)

// Handle function calls
response.choices.forEach { choice ->
    choice.message.functionCall?.let { functionCall ->
        // Find matching Spice tool
        val tool = tools.find { it.name == functionCall.name }

        // Execute locally via Spice
        val params = Json.decodeFromString<Map<String, Any>>(functionCall.arguments)
        val result = tool?.execute(params)

        // Perfect interop between OpenAI and Spice!
    }
}
```

### 2. Adaptive Execution Router

Route between local Spice and remote OpenAI based on complexity:

```kotlin
class AdaptiveRouter(
    private val tools: List<Tool>,
    private val openAI: OpenAI
) {
    suspend fun execute(userMessage: String): String {
        // Simple queries ‚Üí Execute locally via Spice (fast, free)
        if (isSimpleQuery(userMessage)) {
            return executeLocally(userMessage)
        }

        // Complex reasoning ‚Üí Use OpenAI with tools (powerful)
        val openAIFunctions = tools.map { it.toOpenAIFunctionSpec() }

        val response = openAI.chatCompletion(
            ChatCompletionRequest(
                model = ModelId("gpt-4"),
                messages = listOf(ChatMessage(ChatRole.User, userMessage)),
                functions = openAIFunctions
            )
        )

        // Execute tool calls via Spice
        return handleFunctionCalls(response)
    }
}

// Usage
val router = AdaptiveRouter(myTools, openAI)

router.execute("Calculate 42 * 1337")  // ‚Üí Spice (local, instant)
router.execute("Analyze Q3 sales and suggest improvements")  // ‚Üí OpenAI + Spice tools
```

### 3. Testing OpenAI Integrations Locally

Test your OpenAI function calling without hitting the API:

```kotlin
@Test
fun `test OpenAI function calling integration`() = runTest {
    // Create test tool
    val weatherTool = SimpleTool(
        name = "get_weather",
        description = "Get current weather for a city",
        parameterSchemas = mapOf(
            "city" to ParameterSchema("string", "City name", required = true),
            "units" to ParameterSchema("string", "celsius or fahrenheit", required = false)
        )
    ) { params ->
        val city = params["city"] as String
        val units = params["units"] as? String ?: "celsius"
        ToolResult.success("""{"city": "$city", "temp": 22, "units": "$units"}""")
    }

    // Verify OpenAI spec is valid
    val spec = weatherTool.toOpenAIFunctionSpec()

    assertEquals("get_weather", spec["name"])

    val parameters = spec["parameters"] as Map<*, *>
    assertEquals("object", parameters["type"])

    val properties = parameters["properties"] as Map<*, *>
    assertTrue(properties.containsKey("city"))
    assertTrue(properties.containsKey("units"))

    val required = parameters["required"] as List<*>
    assertEquals(listOf("city"), required)

    // Test local execution
    val result = weatherTool.execute(mapOf("city" to "Seoul"))

    assertTrue(result.isSuccess)
    result.fold(
        onSuccess = { toolResult ->
            assertTrue(toolResult.success)
            assertTrue(toolResult.result.contains("Seoul"))
        },
        onFailure = { fail("Should not fail") }
    )

    // ‚úÖ Perfect! Tool works both locally and with OpenAI
}
```

---

## Technical Details

### Automatic Type Mapping

Spice parameter types ‚Üí OpenAI JSON Schema types:

| Spice Type | OpenAI Type | Example |
|------------|-------------|---------|
| `"string"` | `"string"` | "Hello World" |
| `"number"` | `"number"` | 42, 3.14 |
| `"boolean"` | `"boolean"` | true, false |
| `"array"` | `"array"` | [1, 2, 3] |
| `"object"` | `"object"` | `{"key": "value"}` |

### Smart Required Parameter Handling

```kotlin
// Only required parameters in "required" array
ToolSchema(
    name = "send_email",
    description = "Send an email",
    parameters = mapOf(
        "to" to ParameterSchema("string", "Recipient", required = true),
        "subject" to ParameterSchema("string", "Subject", required = true),
        "body" to ParameterSchema("string", "Email body", required = true),
        "cc" to ParameterSchema("array", "CC list", required = false),
        "bcc" to ParameterSchema("array", "BCC list", required = false)
    )
)

// OpenAI spec:
// "required": ["to", "subject", "body"]
// (cc and bcc are optional)
```

If **no parameters are required**, the `required` field is omitted entirely (following OpenAI best practices).

### Default Values

Default values are automatically included:

```kotlin
ToolSchema(
    name = "api_call",
    description = "Call external API",
    parameters = mapOf(
        "endpoint" to ParameterSchema("string", "API endpoint", required = true),
        "timeout" to ParameterSchema(
            type = "number",
            description = "Timeout in seconds",
            required = false,
            default = JsonPrimitive(30)  // ‚úÖ Included in OpenAI spec
        )
    )
)

// OpenAI spec includes:
// "timeout": {
//   "type": "number",
//   "description": "Timeout in seconds",
//   "default": 30
// }
```

---

## Best Practices

### 1. Write Descriptive Schemas

OpenAI models use descriptions to decide when to call functions. Be specific:

```kotlin
// ‚úÖ Good - Clear, actionable description
ToolSchema(
    name = "search_customer_database",
    description = "Search the customer database by email, phone, or customer ID. Returns full customer record including contact details, purchase history, and account status.",
    parameters = mapOf(
        "search_term" to ParameterSchema(
            "string",
            "Customer email (user@example.com), phone (+1-555-555-5555), or ID (CUST-12345)",
            required = true
        )
    )
)

// ‚ùå Bad - Vague description
ToolSchema(
    name = "search",
    description = "Search",
    parameters = mapOf(
        "query" to ParameterSchema("string", "Query", required = true)
    )
)
```

### 2. Mark Required Parameters Correctly

Only mark parameters as required if they're truly mandatory:

```kotlin
// ‚úÖ Good
tool("create_user", "Create a new user account") {
    parameter("email", "string", "User email address", required = true)
    parameter("name", "string", "User full name", required = true)
    parameter("phone", "string", "Phone number (optional)", required = false)
    parameter("company", "string", "Company name (optional)", required = false)
}
```

### 3. Include Examples in Descriptions

Help the model understand expected formats:

```kotlin
tool("schedule_meeting", "Schedule a calendar meeting") {
    parameter(
        "date",
        "string",
        "Meeting date in YYYY-MM-DD format (e.g., 2025-12-31)",
        required = true
    )
    parameter(
        "time",
        "string",
        "Meeting time in HH:MM 24-hour format (e.g., 14:30)",
        required = true
    )
    parameter(
        "duration",
        "number",
        "Duration in minutes (e.g., 30, 60, 90)",
        required = true
    )
}
```

### 4. Test Both Execution Paths

```kotlin
@Test
fun `test tool works with both Spice and OpenAI`() = runTest {
    val tool = MyTool()

    // Test Spice local execution
    val localResult = tool.execute(params)
    assertTrue(localResult.isSuccess)

    // Test OpenAI spec generation
    val spec = tool.toOpenAIFunctionSpec()
    assertNotNull(spec["name"])
    assertNotNull(spec["parameters"])

    // Validate spec structure
    val parameters = spec["parameters"] as Map<*, *>
    assertEquals("object", parameters["type"])
    assertTrue(parameters.containsKey("properties"))
}
```

---

## Migration Guide

### Zero Breaking Changes

This is a purely additive release. All existing code continues to work.

### Getting Started

```kotlin
// 1. Update dependency
implementation("com.github.no-ai-labs.spice-framework:spice-core:0.8.2")

// 2. Convert your tools
val openAISpecs = myTools.map { it.toOpenAIFunctionSpec() }

// 3. Use with OpenAI
val request = ChatCompletionRequest(
    model = ModelId("gpt-4"),
    messages = messages,
    functions = openAISpecs
)
```

### Removing Manual Conversion Code

**Before 0.8.2:**
```kotlin
class WorkflowTool(val spiceTool: Tool) {
    fun toOpenAISpec(): Map<String, Any> {
        // 50 lines of manual conversion...
    }
}
```

**After 0.8.2:**
```kotlin
// Delete the entire WorkflowTool class!
val openAISpec = spiceTool.toOpenAIFunctionSpec()  // Done.
```

---

## What's Next

### Future Enhancements

Based on community feedback, we're considering:

- **Anthropic Claude Tool Spec**: `tool.toClaudeToolSpec()`
- **Google Gemini Function Calling**: `tool.toGeminiFunctionSpec()`
- **Automatic JSON Schema Validation**: Validate outputs against schema
- **Tool Spec Versioning**: Version your function specs
- **Advanced JSON Schema Features**: `oneOf`, `anyOf`, `pattern`, etc.

**Want a feature?** [Open an issue](https://github.com/no-ai-labs/spice/issues) or contribute!

---

## Documentation

- [Tool API Reference](https://github.com/no-ai-labs/spice/blob/main/docs/docs/api/tool.md#openai-function-calling-integration)
- [Tool Patterns: OpenAI Integration](https://github.com/no-ai-labs/spice/blob/main/docs/docs/tools-extensions/tool-patterns.md#7-openai-function-calling-integration)
- [OpenAI Function Calling Docs](https://platform.openai.com/docs/guides/function-calling)
- [Full Release Notes](https://github.com/no-ai-labs/spice/blob/main/RELEASE_NOTES_v0.8.2.md)

---

## Upgrade Now

```kotlin
dependencies {
    implementation("com.github.no-ai-labs.spice-framework:spice-core:0.8.2")
}
```

```xml
<dependency>
    <groupId>com.github.no-ai-labs.spice-framework</groupId>
    <artifactId>spice-core</artifactId>
    <version>0.8.2</version>
</dependency>
```

**Happy building!** üöÄ

---

*Have questions? Join our [GitHub Discussions](https://github.com/no-ai-labs/spice/discussions) or open an [issue](https://github.com/no-ai-labs/spice/issues).*
