package io.github.spice

import java.time.format.DateTimeFormatter

/**
 * ğŸ•¸ï¸ Spice Flow DAG Graphviz Generator
 * 
 * Spice ì‹œìŠ¤í…œì˜ ë©”ì‹œì§€ íë¦„ì„ Graphviz DOT í¬ë§·ìœ¼ë¡œ ì‹œê°í™”í•©ë‹ˆë‹¤.
 * MessageHistoryë¥¼ ê¸°ë°˜ìœ¼ë¡œ Agent ê°„ì˜ ë©”ì‹œì§€ ì „ë‹¬ íë¦„ì„ ê·¸ë˜í”„ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.
 */
class GraphvizFlowGenerator {
    
    /**
     * ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ë¥¼ ê¸°ë°˜ìœ¼ë¡œ Graphviz DOT íŒŒì¼ ìƒì„±
     */
    fun generateDotFromMessages(messages: List<Message>, title: String = "Spice Flow Graph"): String {
        return buildString {
            appendDotHeader(title)
            
            val nodes = extractNodes(messages)
            val edges = extractEdges(messages)
            
            appendNodeDefinitions(nodes)
            appendEdgeDefinitions(edges)
            
            appendDotFooter()
        }.trim()
    }
    
    /**
     * ExecutionContextë¡œë¶€í„° ì§ì ‘ DOT ìƒì„± (ë§Œì•½ êµ¬í˜„ë˜ì–´ ìˆë‹¤ë©´)
     */
    fun generateDotFromContext(context: Any, title: String = "Spice Execution Flow"): String {
        // ExecutionContextê°€ êµ¬í˜„ë˜ë©´ ì—¬ê¸°ì„œ messageHistoryë¥¼ ì¶”ì¶œ
        // ì§€ê¸ˆì€ ì„ì‹œë¡œ ë¹ˆ ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸ë¡œ ì²˜ë¦¬
        return generateDotFromMessages(emptyList(), title)
    }
    
    /**
     * AgentEngineì˜ ì²˜ë¦¬ íë¦„ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ì—¬ DOT ìƒì„±
     */
    fun generateDotFromAgentEngine(
        agentEngine: AgentEngine, 
        sampleMessages: List<Message>, 
        title: String = "Spice Agent Flow"
    ): String {
        val flowMessages = mutableListOf<Message>()
        
        // ìƒ˜í”Œ ë©”ì‹œì§€ë“¤ì„ AgentEngineìœ¼ë¡œ ì²˜ë¦¬í•˜ì—¬ íë¦„ ì¶”ì 
        sampleMessages.forEach { message ->
            try {
                kotlinx.coroutines.runBlocking {
                    val result = agentEngine.receive(message)
                    flowMessages.add(message)
                    flowMessages.add(result.response)
                }
            } catch (e: Exception) {
                // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ì›ë³¸ ë©”ì‹œì§€ëŠ” ì¶”ê°€
                flowMessages.add(message)
            }
        }
        
        return generateDotFromMessages(flowMessages, title)
    }
    
    private fun StringBuilder.appendDotHeader(title: String) {
        appendLine("digraph \"$title\" {")
        appendLine("    // Spice Flow Graph Generated by GraphvizFlowGenerator")
        appendLine("    // $(date)")
        appendLine()
        appendLine("    // Graph attributes")
        appendLine("    rankdir=TB;")
        appendLine("    node [shape=box, style=filled, fontname=\"Arial\"];")
        appendLine("    edge [fontname=\"Arial\", fontsize=10];")
        appendLine("    bgcolor=\"white\";")
        appendLine("    fontname=\"Arial\";")
        appendLine("    fontsize=16;")
        appendLine("    label=\"ğŸŒ¶ï¸ $title\";")
        appendLine("    labelloc=top;")
        appendLine()
    }
    
    private fun StringBuilder.appendDotFooter() {
        appendLine()
        appendLine("    // Legend")
        appendLine("    subgraph cluster_legend {")
        appendLine("        label=\"Legend\";")
        appendLine("        style=filled;")
        appendLine("        color=lightgrey;")
        appendLine("        fontsize=12;")
        appendLine()
        appendLine("        legend_user [label=\"User\", fillcolor=\"lightblue\", shape=ellipse];")
        appendLine("        legend_agent [label=\"Agent\", fillcolor=\"lightgreen\", shape=box];")
        appendLine("        legend_tool [label=\"Tool\", fillcolor=\"orange\", shape=diamond];")
        appendLine("        legend_system [label=\"System\", fillcolor=\"lightgray\", shape=hexagon];")
        appendLine()
        appendLine("        legend_user -> legend_agent [label=\"TEXT\", color=\"blue\"];")
        appendLine("        legend_agent -> legend_tool [label=\"TOOL_CALL\", color=\"red\"];")
        appendLine("        legend_tool -> legend_agent [label=\"TOOL_RESULT\", color=\"green\"];")
        appendLine("        legend_agent -> legend_user [label=\"RESPONSE\", color=\"purple\"];")
        appendLine("    }")
        appendLine("}")
    }
    
    private fun extractNodes(messages: List<Message>): Set<MessageNode> {
        val nodes = mutableSetOf<MessageNode>()
        
        messages.forEach { message ->
            nodes.add(MessageNode(
                id = message.sender,
                label = message.sender,
                type = when {
                    message.sender.contains("user", ignoreCase = true) -> NodeType.USER
                    message.sender.contains("agent", ignoreCase = true) -> NodeType.AGENT
                    message.sender.contains("tool", ignoreCase = true) -> NodeType.TOOL
                    message.sender.contains("system", ignoreCase = true) -> NodeType.SYSTEM
                    else -> NodeType.AGENT
                }
            ))
            
            message.receiver?.let { receiver ->
                nodes.add(MessageNode(
                    id = receiver,
                    label = receiver,
                    type = when {
                        receiver.contains("user", ignoreCase = true) -> NodeType.USER
                        receiver.contains("agent", ignoreCase = true) -> NodeType.AGENT
                        receiver.contains("tool", ignoreCase = true) -> NodeType.TOOL
                        receiver.contains("system", ignoreCase = true) -> NodeType.SYSTEM
                        else -> NodeType.AGENT
                    }
                ))
            }
        }
        
        return nodes
    }
    
    private fun extractEdges(messages: List<Message>): List<MessageEdge> {
        val edges = mutableListOf<MessageEdge>()
        
        messages.forEach { message ->
            val receiver = message.receiver ?: "system"
            
            edges.add(MessageEdge(
                from = message.sender,
                to = receiver,
                label = message.type.toString(),
                messageType = message.type,
                content = message.content.take(30) + if (message.content.length > 30) "..." else "",
                metadata = message.metadata
            ))
        }
        
        // ì—°ì†ëœ ë©”ì‹œì§€ë“¤ ê°„ì˜ ì—°ê²° ì¶”ê°€
        for (i in 0 until messages.size - 1) {
            val current = messages[i]
            val next = messages[i + 1]
            
            // ëŒ€í™” íë¦„ì´ë‚˜ parentId ê´€ê³„ê°€ ìˆëŠ” ê²½ìš° ì—°ê²°
            if (next.parentId == current.id || 
                next.conversationId == current.conversationId ||
                current.receiver == next.sender) {
                
                edges.add(MessageEdge(
                    from = current.receiver ?: current.sender,
                    to = next.sender,
                    label = "â†’",
                    messageType = MessageType.SYSTEM,
                    content = "flow",
                    metadata = mapOf("type" to "continuation"),
                    style = "dashed"
                ))
            }
        }
        
        return edges
    }
    
    private fun StringBuilder.appendNodeDefinitions(nodes: Set<MessageNode>) {
        appendLine("    // Node definitions")
        nodes.forEach { node ->
            val safeId = node.id.replace("-", "_").replace(" ", "_")
            val fillColor = when (node.type) {
                NodeType.USER -> "lightblue"
                NodeType.AGENT -> "lightgreen"
                NodeType.TOOL -> "orange"
                NodeType.SYSTEM -> "lightgray"
            }
            val shape = when (node.type) {
                NodeType.USER -> "ellipse"
                NodeType.AGENT -> "box"
                NodeType.TOOL -> "diamond"
                NodeType.SYSTEM -> "hexagon"
            }
            
            appendLine("    $safeId [label=\"${node.label}\", fillcolor=\"$fillColor\", shape=$shape];")
        }
        appendLine()
    }
    
    private fun StringBuilder.appendEdgeDefinitions(edges: List<MessageEdge>) {
        appendLine("    // Edge definitions")
        edges.forEachIndexed { index, edge ->
            val safeFrom = edge.from.replace("-", "_").replace(" ", "_")
            val safeTo = edge.to.replace("-", "_").replace(" ", "_")
            
            val color = when (edge.messageType) {
                MessageType.TEXT -> "blue"
                MessageType.PROMPT -> "purple"
                MessageType.TOOL_CALL -> "red"
                MessageType.TOOL_RESULT -> "green"
                MessageType.DATA -> "orange"
                MessageType.RESULT -> "darkgreen"
                MessageType.ERROR -> "red"
                MessageType.WORKFLOW_START -> "navy"
                MessageType.WORKFLOW_END -> "navy"
                MessageType.BRANCH -> "brown"
                MessageType.MERGE -> "brown"
                MessageType.INTERRUPT -> "crimson"
                MessageType.RESUME -> "darkblue"
                else -> "black"
            }
            
            val style = edge.style ?: "solid"
            val tooltip = edge.content.replace("\"", "\\\"")
            
            // ë©”íƒ€ë°ì´í„°ë¥¼ tooltipì— í¬í•¨
            val metadataStr = if (edge.metadata.isNotEmpty()) {
                edge.metadata.entries.joinToString(", ") { "${it.key}=${it.value}" }
            } else ""
            
            val fullTooltip = if (metadataStr.isNotEmpty()) {
                "$tooltip ($metadataStr)"
            } else tooltip
            
            appendLine("    $safeFrom -> $safeTo [")
            appendLine("        label=\"${edge.label}\",")
            appendLine("        color=\"$color\",")
            appendLine("        style=\"$style\",")
            appendLine("        tooltip=\"$fullTooltip\",")
            appendLine("        fontcolor=\"$color\"")
            appendLine("    ];")
        }
        appendLine()
    }
}

/**
 * ê·¸ë˜í”„ ë…¸ë“œ íƒ€ì…
 */
enum class NodeType {
    USER, AGENT, TOOL, SYSTEM
}

/**
 * ë©”ì‹œì§€ ë…¸ë“œ ì •ë³´
 */
data class MessageNode(
    val id: String,
    val label: String,
    val type: NodeType
)

/**
 * ë©”ì‹œì§€ ê°„ì„  ì •ë³´
 */
data class MessageEdge(
    val from: String,
    val to: String,
    val label: String,
    val messageType: MessageType,
    val content: String,
    val metadata: Map<String, String> = emptyMap(),
    val style: String? = null
)

/**
 * í™•ì¥ í•¨ìˆ˜: Message ë¦¬ìŠ¤íŠ¸ë¡œë¶€í„° DOT ìƒì„±
 */
fun List<Message>.generateGraphvizDot(title: String = "Message Flow"): String {
    return GraphvizFlowGenerator().generateDotFromMessages(this, title)
}

/**
 * í™•ì¥ í•¨ìˆ˜: AgentEngineìœ¼ë¡œë¶€í„° í”Œë¡œìš° DOT ìƒì„±
 */
fun AgentEngine.generateFlowDot(
    sampleMessages: List<Message>, 
    title: String = "Agent Processing Flow"
): String {
    return GraphvizFlowGenerator().generateDotFromAgentEngine(this, sampleMessages, title)
}

/**
 * íŒŒì¼ë¡œ DOT ì €ì¥
 */
fun String.saveToDotFile(filePath: String = "spice_flow.dot") {
    java.io.File(filePath).writeText(this)
    println("ğŸ•¸ï¸ Graphviz DOT file saved to: $filePath")
    println("ğŸ’¡ Generate image with: dot -Tpng $filePath -o ${filePath.replace(".dot", ".png")}")
}

/**
 * í¸ì˜ í•¨ìˆ˜: ì›Œí¬í”Œë¡œìš° ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•œ ìƒ˜í”Œ ë©”ì‹œì§€ ìƒì„±
 */
fun createSampleWorkflow(): List<Message> {
    val messages = mutableListOf<Message>()
    
    // 1. ì›Œí¬í”Œë¡œìš° ì‹œì‘
    val startMessage = Message(
        content = "Start data processing workflow",
        sender = "user",
        receiver = "workflow-manager",
        type = MessageType.WORKFLOW_START
    )
    messages.add(startMessage)
    
    // 2. ë°ì´í„° ìˆ˜ì§‘
    val dataMessage = startMessage.createReply(
        content = "Collecting data from sources",
        sender = "data-agent",
        type = MessageType.DATA
    )
    messages.add(dataMessage)
    
    // 3. ë„êµ¬ í˜¸ì¶œ
    val toolMessage = dataMessage.createReply(
        content = "Process collected data",
        sender = "data-processor",
        type = MessageType.TOOL_CALL,
        metadata = mapOf("toolName" to "data_analyzer")
    )
    messages.add(toolMessage)
    
    // 4. ë„êµ¬ ê²°ê³¼
    val toolResult = toolMessage.createReply(
        content = "Data analysis completed successfully",
        sender = "analysis-tool",
        type = MessageType.TOOL_RESULT
    )
    messages.add(toolResult)
    
    // 5. ë¶„ê¸° ì²˜ë¦¬
    val branchMessage = toolResult.createReply(
        content = "Determine next processing step",
        sender = "data-processor",
        type = MessageType.BRANCH
    )
    messages.add(branchMessage)
    
    // 6. ê²°ê³¼ ìƒì„±
    val resultMessage = branchMessage.createReply(
        content = "Generate final report",
        sender = "result-agent",
        type = MessageType.RESULT
    )
    messages.add(resultMessage)
    
    // 7. ì›Œí¬í”Œë¡œìš° ì¢…ë£Œ
    val endMessage = resultMessage.createReply(
        content = "Workflow completed successfully",
        sender = "workflow-manager",
        type = MessageType.WORKFLOW_END
    )
    messages.add(endMessage)
    
    return messages
}

/**
 * ì—ëŸ¬ íë¦„ ì‹œë®¬ë ˆì´ì…˜
 */
fun createErrorWorkflow(): List<Message> {
    val messages = mutableListOf<Message>()
    
    val startMessage = Message(
        content = "Start risky operation",
        sender = "user",
        receiver = "risky-agent",
        type = MessageType.TEXT
    )
    messages.add(startMessage)
    
    val toolCall = startMessage.createReply(
        content = "Execute dangerous operation",
        sender = "risky-agent",
        type = MessageType.TOOL_CALL,
        metadata = mapOf("toolName" to "dangerous_operation")
    )
    messages.add(toolCall)
    
    val errorResult = toolCall.createReply(
        content = "Operation failed: Insufficient permissions",
        sender = "dangerous-tool",
        type = MessageType.ERROR
    )
    messages.add(errorResult)
    
    val errorResponse = errorResult.createReply(
        content = "Error handled: Switching to safe mode",
        sender = "risky-agent",
        type = MessageType.ERROR
    )
    messages.add(errorResponse)
    
    return messages
}

/**
 * ì¸í„°ëŸ½íŠ¸/ì¬ê°œ íë¦„ ì‹œë®¬ë ˆì´ì…˜
 */
fun createInterruptWorkflow(): List<Message> {
    val messages = mutableListOf<Message>()
    
    val startMessage = Message(
        content = "Start long running task",
        sender = "user",
        receiver = "worker-agent",
        type = MessageType.TEXT
    )
    messages.add(startMessage)
    
    val processingMessage = startMessage.createReply(
        content = "Processing large dataset...",
        sender = "worker-agent",
        type = MessageType.TEXT
    )
    messages.add(processingMessage)
    
    val interruptMessage = processingMessage.createReply(
        content = "Need user input for next step",
        sender = "worker-agent",
        type = MessageType.INTERRUPT,
        metadata = mapOf("reason" to "user_input_required")
    )
    messages.add(interruptMessage)
    
    val userInput = interruptMessage.createReply(
        content = "Continue with option A",
        sender = "user",
        type = MessageType.TEXT
    )
    messages.add(userInput)
    
    val resumeMessage = userInput.createReply(
        content = "Resuming with option A",
        sender = "worker-agent",
        type = MessageType.RESUME
    )
    messages.add(resumeMessage)
    
    val completionMessage = resumeMessage.createReply(
        content = "Task completed successfully",
        sender = "worker-agent",
        type = MessageType.TEXT
    )
    messages.add(completionMessage)
    
    return messages
} 