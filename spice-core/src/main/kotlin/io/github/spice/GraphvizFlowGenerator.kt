package io.github.spice

import java.time.format.DateTimeFormatter

/**
 * 🕸️ Spice Flow DAG Graphviz Generator
 * 
 * Spice 시스템의 메시지 흐름을 Graphviz DOT 포맷으로 시각화합니다.
 * MessageHistory를 기반으로 Agent 간의 메시지 전달 흐름을 그래프로 표현합니다.
 */
class GraphvizFlowGenerator {
    
    /**
     * 메시지 히스토리를 기반으로 Graphviz DOT 파일 생성
     */
    fun generateDotFromMessages(messages: List<Message>, title: String = "Spice Flow Graph"): String {
        return buildString {
            appendDotHeader(title)
            
            val nodes = extractNodes(messages)
            val edges = extractEdges(messages)
            
            appendNodeDefinitions(nodes)
            appendEdgeDefinitions(edges)
            
            appendDotFooter()
        }.trim()
    }
    
    /**
     * ExecutionContext로부터 직접 DOT 생성 (만약 구현되어 있다면)
     */
    fun generateDotFromContext(context: Any, title: String = "Spice Execution Flow"): String {
        // ExecutionContext가 구현되면 여기서 messageHistory를 추출
        // 지금은 임시로 빈 메시지 리스트로 처리
        return generateDotFromMessages(emptyList(), title)
    }
    
    /**
     * AgentEngine의 처리 흐름을 시뮬레이션하여 DOT 생성
     */
    fun generateDotFromAgentEngine(
        agentEngine: AgentEngine, 
        sampleMessages: List<Message>, 
        title: String = "Spice Agent Flow"
    ): String {
        val flowMessages = mutableListOf<Message>()
        
        // 샘플 메시지들을 AgentEngine으로 처리하여 흐름 추적
        sampleMessages.forEach { message ->
            try {
                kotlinx.coroutines.runBlocking {
                    val result = agentEngine.receive(message)
                    flowMessages.add(message)
                    flowMessages.add(result.response)
                }
            } catch (e: Exception) {
                // 에러가 발생해도 원본 메시지는 추가
                flowMessages.add(message)
            }
        }
        
        return generateDotFromMessages(flowMessages, title)
    }
    
    private fun StringBuilder.appendDotHeader(title: String) {
        appendLine("digraph \"$title\" {")
        appendLine("    // Spice Flow Graph Generated by GraphvizFlowGenerator")
        appendLine("    // $(date)")
        appendLine()
        appendLine("    // Graph attributes")
        appendLine("    rankdir=TB;")
        appendLine("    node [shape=box, style=filled, fontname=\"Arial\"];")
        appendLine("    edge [fontname=\"Arial\", fontsize=10];")
        appendLine("    bgcolor=\"white\";")
        appendLine("    fontname=\"Arial\";")
        appendLine("    fontsize=16;")
        appendLine("    label=\"🌶️ $title\";")
        appendLine("    labelloc=top;")
        appendLine()
    }
    
    private fun StringBuilder.appendDotFooter() {
        appendLine()
        appendLine("    // Legend")
        appendLine("    subgraph cluster_legend {")
        appendLine("        label=\"Legend\";")
        appendLine("        style=filled;")
        appendLine("        color=lightgrey;")
        appendLine("        fontsize=12;")
        appendLine()
        appendLine("        legend_user [label=\"User\", fillcolor=\"lightblue\", shape=ellipse];")
        appendLine("        legend_agent [label=\"Agent\", fillcolor=\"lightgreen\", shape=box];")
        appendLine("        legend_tool [label=\"Tool\", fillcolor=\"orange\", shape=diamond];")
        appendLine("        legend_system [label=\"System\", fillcolor=\"lightgray\", shape=hexagon];")
        appendLine()
        appendLine("        legend_user -> legend_agent [label=\"TEXT\", color=\"blue\"];")
        appendLine("        legend_agent -> legend_tool [label=\"TOOL_CALL\", color=\"red\"];")
        appendLine("        legend_tool -> legend_agent [label=\"TOOL_RESULT\", color=\"green\"];")
        appendLine("        legend_agent -> legend_user [label=\"RESPONSE\", color=\"purple\"];")
        appendLine("    }")
        appendLine("}")
    }
    
    private fun extractNodes(messages: List<Message>): Set<MessageNode> {
        val nodes = mutableSetOf<MessageNode>()
        
        messages.forEach { message ->
            nodes.add(MessageNode(
                id = message.sender,
                label = message.sender,
                type = when {
                    message.sender.contains("user", ignoreCase = true) -> NodeType.USER
                    message.sender.contains("agent", ignoreCase = true) -> NodeType.AGENT
                    message.sender.contains("tool", ignoreCase = true) -> NodeType.TOOL
                    message.sender.contains("system", ignoreCase = true) -> NodeType.SYSTEM
                    else -> NodeType.AGENT
                }
            ))
            
            message.receiver?.let { receiver ->
                nodes.add(MessageNode(
                    id = receiver,
                    label = receiver,
                    type = when {
                        receiver.contains("user", ignoreCase = true) -> NodeType.USER
                        receiver.contains("agent", ignoreCase = true) -> NodeType.AGENT
                        receiver.contains("tool", ignoreCase = true) -> NodeType.TOOL
                        receiver.contains("system", ignoreCase = true) -> NodeType.SYSTEM
                        else -> NodeType.AGENT
                    }
                ))
            }
        }
        
        return nodes
    }
    
    private fun extractEdges(messages: List<Message>): List<MessageEdge> {
        val edges = mutableListOf<MessageEdge>()
        
        messages.forEach { message ->
            val receiver = message.receiver ?: "system"
            
            edges.add(MessageEdge(
                from = message.sender,
                to = receiver,
                label = message.type.toString(),
                messageType = message.type,
                content = message.content.take(30) + if (message.content.length > 30) "..." else "",
                metadata = message.metadata
            ))
        }
        
        // 연속된 메시지들 간의 연결 추가
        for (i in 0 until messages.size - 1) {
            val current = messages[i]
            val next = messages[i + 1]
            
            // 대화 흐름이나 parentId 관계가 있는 경우 연결
            if (next.parentId == current.id || 
                next.conversationId == current.conversationId ||
                current.receiver == next.sender) {
                
                edges.add(MessageEdge(
                    from = current.receiver ?: current.sender,
                    to = next.sender,
                    label = "→",
                    messageType = MessageType.SYSTEM,
                    content = "flow",
                    metadata = mapOf("type" to "continuation"),
                    style = "dashed"
                ))
            }
        }
        
        return edges
    }
    
    private fun StringBuilder.appendNodeDefinitions(nodes: Set<MessageNode>) {
        appendLine("    // Node definitions")
        nodes.forEach { node ->
            val safeId = node.id.replace("-", "_").replace(" ", "_")
            val fillColor = when (node.type) {
                NodeType.USER -> "lightblue"
                NodeType.AGENT -> "lightgreen"
                NodeType.TOOL -> "orange"
                NodeType.SYSTEM -> "lightgray"
            }
            val shape = when (node.type) {
                NodeType.USER -> "ellipse"
                NodeType.AGENT -> "box"
                NodeType.TOOL -> "diamond"
                NodeType.SYSTEM -> "hexagon"
            }
            
            appendLine("    $safeId [label=\"${node.label}\", fillcolor=\"$fillColor\", shape=$shape];")
        }
        appendLine()
    }
    
    private fun StringBuilder.appendEdgeDefinitions(edges: List<MessageEdge>) {
        appendLine("    // Edge definitions")
        edges.forEachIndexed { index, edge ->
            val safeFrom = edge.from.replace("-", "_").replace(" ", "_")
            val safeTo = edge.to.replace("-", "_").replace(" ", "_")
            
            val color = when (edge.messageType) {
                MessageType.TEXT -> "blue"
                MessageType.PROMPT -> "purple"
                MessageType.TOOL_CALL -> "red"
                MessageType.TOOL_RESULT -> "green"
                MessageType.DATA -> "orange"
                MessageType.RESULT -> "darkgreen"
                MessageType.ERROR -> "red"
                MessageType.WORKFLOW_START -> "navy"
                MessageType.WORKFLOW_END -> "navy"
                MessageType.BRANCH -> "brown"
                MessageType.MERGE -> "brown"
                MessageType.INTERRUPT -> "crimson"
                MessageType.RESUME -> "darkblue"
                else -> "black"
            }
            
            val style = edge.style ?: "solid"
            val tooltip = edge.content.replace("\"", "\\\"")
            
            // 메타데이터를 tooltip에 포함
            val metadataStr = if (edge.metadata.isNotEmpty()) {
                edge.metadata.entries.joinToString(", ") { "${it.key}=${it.value}" }
            } else ""
            
            val fullTooltip = if (metadataStr.isNotEmpty()) {
                "$tooltip ($metadataStr)"
            } else tooltip
            
            appendLine("    $safeFrom -> $safeTo [")
            appendLine("        label=\"${edge.label}\",")
            appendLine("        color=\"$color\",")
            appendLine("        style=\"$style\",")
            appendLine("        tooltip=\"$fullTooltip\",")
            appendLine("        fontcolor=\"$color\"")
            appendLine("    ];")
        }
        appendLine()
    }
}

/**
 * 그래프 노드 타입
 */
enum class NodeType {
    USER, AGENT, TOOL, SYSTEM
}

/**
 * 메시지 노드 정보
 */
data class MessageNode(
    val id: String,
    val label: String,
    val type: NodeType
)

/**
 * 메시지 간선 정보
 */
data class MessageEdge(
    val from: String,
    val to: String,
    val label: String,
    val messageType: MessageType,
    val content: String,
    val metadata: Map<String, String> = emptyMap(),
    val style: String? = null
)

/**
 * 확장 함수: Message 리스트로부터 DOT 생성
 */
fun List<Message>.generateGraphvizDot(title: String = "Message Flow"): String {
    return GraphvizFlowGenerator().generateDotFromMessages(this, title)
}

/**
 * 확장 함수: AgentEngine으로부터 플로우 DOT 생성
 */
fun AgentEngine.generateFlowDot(
    sampleMessages: List<Message>, 
    title: String = "Agent Processing Flow"
): String {
    return GraphvizFlowGenerator().generateDotFromAgentEngine(this, sampleMessages, title)
}

/**
 * 파일로 DOT 저장
 */
fun String.saveToDotFile(filePath: String = "spice_flow.dot") {
    java.io.File(filePath).writeText(this)
    println("🕸️ Graphviz DOT file saved to: $filePath")
    println("💡 Generate image with: dot -Tpng $filePath -o ${filePath.replace(".dot", ".png")}")
}

/**
 * 편의 함수: 워크플로우 시뮬레이션을 위한 샘플 메시지 생성
 */
fun createSampleWorkflow(): List<Message> {
    val messages = mutableListOf<Message>()
    
    // 1. 워크플로우 시작
    val startMessage = Message(
        content = "Start data processing workflow",
        sender = "user",
        receiver = "workflow-manager",
        type = MessageType.WORKFLOW_START
    )
    messages.add(startMessage)
    
    // 2. 데이터 수집
    val dataMessage = startMessage.createReply(
        content = "Collecting data from sources",
        sender = "data-agent",
        type = MessageType.DATA
    )
    messages.add(dataMessage)
    
    // 3. 도구 호출
    val toolMessage = dataMessage.createReply(
        content = "Process collected data",
        sender = "data-processor",
        type = MessageType.TOOL_CALL,
        metadata = mapOf("toolName" to "data_analyzer")
    )
    messages.add(toolMessage)
    
    // 4. 도구 결과
    val toolResult = toolMessage.createReply(
        content = "Data analysis completed successfully",
        sender = "analysis-tool",
        type = MessageType.TOOL_RESULT
    )
    messages.add(toolResult)
    
    // 5. 분기 처리
    val branchMessage = toolResult.createReply(
        content = "Determine next processing step",
        sender = "data-processor",
        type = MessageType.BRANCH
    )
    messages.add(branchMessage)
    
    // 6. 결과 생성
    val resultMessage = branchMessage.createReply(
        content = "Generate final report",
        sender = "result-agent",
        type = MessageType.RESULT
    )
    messages.add(resultMessage)
    
    // 7. 워크플로우 종료
    val endMessage = resultMessage.createReply(
        content = "Workflow completed successfully",
        sender = "workflow-manager",
        type = MessageType.WORKFLOW_END
    )
    messages.add(endMessage)
    
    return messages
}

/**
 * 에러 흐름 시뮬레이션
 */
fun createErrorWorkflow(): List<Message> {
    val messages = mutableListOf<Message>()
    
    val startMessage = Message(
        content = "Start risky operation",
        sender = "user",
        receiver = "risky-agent",
        type = MessageType.TEXT
    )
    messages.add(startMessage)
    
    val toolCall = startMessage.createReply(
        content = "Execute dangerous operation",
        sender = "risky-agent",
        type = MessageType.TOOL_CALL,
        metadata = mapOf("toolName" to "dangerous_operation")
    )
    messages.add(toolCall)
    
    val errorResult = toolCall.createReply(
        content = "Operation failed: Insufficient permissions",
        sender = "dangerous-tool",
        type = MessageType.ERROR
    )
    messages.add(errorResult)
    
    val errorResponse = errorResult.createReply(
        content = "Error handled: Switching to safe mode",
        sender = "risky-agent",
        type = MessageType.ERROR
    )
    messages.add(errorResponse)
    
    return messages
}

/**
 * 인터럽트/재개 흐름 시뮬레이션
 */
fun createInterruptWorkflow(): List<Message> {
    val messages = mutableListOf<Message>()
    
    val startMessage = Message(
        content = "Start long running task",
        sender = "user",
        receiver = "worker-agent",
        type = MessageType.TEXT
    )
    messages.add(startMessage)
    
    val processingMessage = startMessage.createReply(
        content = "Processing large dataset...",
        sender = "worker-agent",
        type = MessageType.TEXT
    )
    messages.add(processingMessage)
    
    val interruptMessage = processingMessage.createReply(
        content = "Need user input for next step",
        sender = "worker-agent",
        type = MessageType.INTERRUPT,
        metadata = mapOf("reason" to "user_input_required")
    )
    messages.add(interruptMessage)
    
    val userInput = interruptMessage.createReply(
        content = "Continue with option A",
        sender = "user",
        type = MessageType.TEXT
    )
    messages.add(userInput)
    
    val resumeMessage = userInput.createReply(
        content = "Resuming with option A",
        sender = "worker-agent",
        type = MessageType.RESUME
    )
    messages.add(resumeMessage)
    
    val completionMessage = resumeMessage.createReply(
        content = "Task completed successfully",
        sender = "worker-agent",
        type = MessageType.TEXT
    )
    messages.add(completionMessage)
    
    return messages
} 